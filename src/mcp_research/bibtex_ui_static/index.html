<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>BibTeX Metadata Workspace</title>
    <link
      rel="stylesheet"
      href="https://cdn.jsdelivr.net/npm/handsontable@14.5.0/dist/handsontable.full.min.css"
    />
    <style>
      :root {
        --bg: #f4f0e8;
        --bg-accent: #efe4d2;
        --panel: #fffdf8;
        --panel-alt: #f8f3ea;
        --ink: #2c2a24;
        --muted: #6f6a5f;
        --line: #d8cfbe;
        --brand: #a8432b;
        --brand-soft: #f6d9cf;
        --ok: #2e7a57;
        --radius: 14px;
      }

      * {
        box-sizing: border-box;
      }

      body {
        margin: 0;
        min-height: 100vh;
        font-family: "Space Grotesk", "Avenir Next", "Trebuchet MS", sans-serif;
        color: var(--ink);
        background:
          radial-gradient(circle at 0% 0%, rgba(168, 67, 43, 0.14), transparent 40%),
          radial-gradient(circle at 100% 100%, rgba(30, 130, 107, 0.12), transparent 44%),
          linear-gradient(150deg, var(--bg), var(--bg-accent));
      }

      .app-shell {
        display: grid;
        grid-template-columns: 260px 1fr 360px;
        gap: 14px;
        padding: 14px;
        height: 100vh;
      }

      .app-shell.bulk-mode {
        grid-template-columns: 260px 1fr;
      }

      .app-shell.bulk-mode .right-pane {
        display: none;
      }

      .pane {
        background: color-mix(in oklab, var(--panel) 88%, white 12%);
        border: 1px solid var(--line);
        border-radius: var(--radius);
        overflow: hidden;
        min-height: 0;
        box-shadow: 0 10px 30px rgba(44, 42, 36, 0.07);
      }

      .pane-header {
        padding: 14px 16px 10px;
        border-bottom: 1px solid var(--line);
        background: linear-gradient(180deg, color-mix(in oklab, var(--panel-alt) 92%, white 8%), var(--panel));
      }

      .pane-title {
        margin: 0;
        font-family: "Fraunces", "Iowan Old Style", "Times New Roman", serif;
        font-size: 19px;
        line-height: 1.1;
        letter-spacing: 0.2px;
      }

      .pane-subtitle {
        margin-top: 5px;
        font-size: 12px;
        color: var(--muted);
      }

      .left-pane-content {
        padding: 10px;
        display: flex;
        flex-direction: column;
        gap: 8px;
      }

      .bucket-btn {
        border: 1px solid var(--line);
        background: var(--panel-alt);
        color: var(--ink);
        border-radius: 11px;
        cursor: pointer;
        padding: 10px 12px;
        text-align: left;
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 8px;
        transition: 140ms ease;
      }

      .bucket-btn:hover {
        border-color: color-mix(in oklab, var(--brand) 35%, var(--line));
        transform: translateX(2px);
      }

      .bucket-btn.active {
        border-color: var(--brand);
        background: var(--brand-soft);
      }

      .bucket-name {
        font-size: 13px;
        font-weight: 600;
        word-break: break-word;
      }

      .bucket-count {
        font-size: 11px;
        color: var(--muted);
        border: 1px solid var(--line);
        border-radius: 999px;
        padding: 2px 7px;
        background: var(--panel);
      }

      .main-pane-body {
        display: flex;
        flex-direction: column;
        height: calc(100% - 70px);
      }

      .table-wrap {
        padding: 10px;
        overflow: auto;
      }

      table {
        width: 100%;
        border-collapse: collapse;
        min-width: 690px;
      }

      th,
      td {
        border-bottom: 1px solid var(--line);
        padding: 9px 8px;
        font-size: 13px;
        vertical-align: top;
      }

      th {
        text-align: left;
        color: var(--muted);
        font-size: 11px;
        text-transform: uppercase;
        letter-spacing: 0.06em;
        position: sticky;
        top: 0;
        background: color-mix(in oklab, var(--panel) 94%, white 6%);
      }

      .sort-btn {
        border: none;
        background: transparent;
        color: inherit;
        font: inherit;
        text-transform: inherit;
        letter-spacing: inherit;
        cursor: pointer;
        padding: 0;
        display: inline-flex;
        align-items: center;
        gap: 6px;
      }

      .sort-btn.active {
        color: color-mix(in oklab, var(--brand) 72%, var(--muted));
      }

      .sort-indicator {
        font-size: 10px;
        line-height: 1;
      }

      .file-link {
        color: color-mix(in oklab, var(--brand) 70%, #1f5a4d);
        text-decoration: none;
        font-size: 12px;
        font-weight: 600;
        display: inline-flex;
        align-items: center;
        justify-content: center;
        line-height: 1;
        padding: 4px;
        border-radius: 8px;
      }

      .file-link:hover {
        background: color-mix(in oklab, var(--panel-alt) 80%, white 20%);
      }

      .file-link:focus-visible {
        outline: 2px solid color-mix(in oklab, var(--brand) 70%, white 30%);
        outline-offset: 2px;
      }

      .file-link svg {
        width: 16px;
        height: 16px;
        fill: currentColor;
      }

      .file-action-chip {
        display: inline-flex;
        align-items: center;
        justify-content: center;
        min-width: 28px;
        height: 20px;
        border-radius: 6px;
        border: 1px solid var(--line);
        font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;
        font-size: 10px;
        font-weight: 800;
        letter-spacing: 0.04em;
        line-height: 1;
        padding: 0 6px;
      }

      .file-action-chip-pdf {
        background: color-mix(in oklab, #f3d2c8 74%, white 26%);
        color: color-mix(in oklab, #8d2c1b 80%, var(--ink));
        border-color: color-mix(in oklab, #b54b31 40%, var(--line));
      }

      .file-action-chip-md {
        background: color-mix(in oklab, #d9efe5 74%, white 26%);
        color: color-mix(in oklab, #1f7c60 80%, var(--ink));
        border-color: color-mix(in oklab, #2e7a57 42%, var(--line));
      }

      .file-actions {
        display: inline-flex;
        align-items: center;
        justify-content: center;
        gap: 6px;
      }

      .icon-btn {
        border: none;
        background: transparent;
        cursor: pointer;
      }

      .icon-btn:disabled {
        opacity: 0.45;
        cursor: not-allowed;
      }

      .pdf-cell {
        text-align: center;
      }

      .sr-only {
        position: absolute;
        width: 1px;
        height: 1px;
        padding: 0;
        margin: -1px;
        overflow: hidden;
        clip: rect(0, 0, 0, 0);
        white-space: nowrap;
        border: 0;
      }

      .redis-stats {
        border: 1px solid var(--line);
        border-radius: 10px;
        padding: 9px;
        background: color-mix(in oklab, var(--panel-alt) 76%, white 24%);
      }

      .redis-stats-title {
        font-size: 11px;
        letter-spacing: 0.06em;
        text-transform: uppercase;
        color: var(--muted);
      }

      .redis-stats-grid {
        margin-top: 7px;
        display: grid;
        grid-template-columns: 1fr;
        gap: 8px;
      }

      .redis-stat-btn {
        border: 1px solid var(--line);
        border-radius: 9px;
        padding: 8px 9px;
        text-align: left;
        background: var(--panel);
        color: var(--ink);
        font: inherit;
        cursor: pointer;
      }

      .redis-stat-btn:hover {
        border-color: color-mix(in oklab, var(--brand) 40%, var(--line));
      }

      .redis-stat-btn[disabled] {
        opacity: 0.58;
        cursor: not-allowed;
      }

      .redis-stat-count {
        font-size: 16px;
        font-weight: 700;
        line-height: 1.1;
      }

      .redis-stat-label {
        margin-top: 2px;
        font-size: 11px;
        color: var(--muted);
      }

      .redis-stats-meta {
        margin-top: 7px;
        font-size: 11px;
        color: var(--muted);
      }

      tbody tr {
        cursor: pointer;
      }

      tbody tr.active {
        background: color-mix(in oklab, var(--brand-soft) 62%, white 38%);
      }

      .file-name {
        font-weight: 600;
        font-size: 12px;
      }

      .table-input {
        width: 100%;
        border: 1px solid var(--line);
        border-radius: 8px;
        padding: 7px 8px;
        font: inherit;
        background: var(--panel);
        color: var(--ink);
      }

      .table-input:focus,
      .editor-input:focus,
      .editor-textarea:focus,
      .editor-select:focus {
        border-color: color-mix(in oklab, var(--brand) 55%, var(--line));
        box-shadow: 0 0 0 3px rgba(168, 67, 43, 0.13);
        outline: none;
      }

      .main-footer {
        margin-top: auto;
        border-top: 1px solid var(--line);
        padding: 10px 12px;
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 12px;
        color: var(--muted);
        font-size: 12px;
      }

      .main-tools {
        margin-top: 8px;
        display: grid;
        grid-template-columns: auto 1fr;
        gap: 10px;
        align-items: center;
      }

      .view-toggle {
        margin-top: 8px;
        display: inline-flex;
        border: 1px solid var(--line);
        border-radius: 10px;
        overflow: hidden;
        width: fit-content;
        background: color-mix(in oklab, var(--panel-alt) 78%, white 22%);
      }

      .view-toggle-btn {
        border: none;
        border-right: 1px solid var(--line);
        background: transparent;
        color: var(--muted);
        font: inherit;
        font-size: 12px;
        font-weight: 600;
        padding: 6px 10px;
        cursor: pointer;
      }

      .view-toggle-btn:last-child {
        border-right: none;
      }

      .view-toggle-btn.active {
        background: color-mix(in oklab, var(--brand-soft) 78%, white 22%);
        color: color-mix(in oklab, var(--brand) 75%, #4c2318);
      }

      .main-action-btn {
        border: 1px solid color-mix(in oklab, var(--brand) 35%, var(--line));
        background: color-mix(in oklab, var(--brand-soft) 72%, white 28%);
        color: color-mix(in oklab, var(--brand) 78%, #4c2318);
        border-radius: 9px;
        padding: 7px 10px;
        font: inherit;
        font-size: 12px;
        font-weight: 600;
        cursor: pointer;
      }

      .main-action-btn:hover {
        border-color: color-mix(in oklab, var(--brand) 65%, var(--line));
      }

      .main-action-btn:disabled {
        opacity: 0.55;
        cursor: not-allowed;
      }

      .autofill-status {
        font-size: 12px;
        color: var(--muted);
      }

      .autofill-progress {
        margin-top: 8px;
      }

      .autofill-progress[hidden] {
        display: none !important;
      }

      .autofill-progress-track {
        height: 10px;
        border-radius: 999px;
        border: 1px solid var(--line);
        background: color-mix(in oklab, var(--panel-alt) 84%, white 16%);
        overflow: hidden;
      }

      .autofill-progress-fill {
        height: 100%;
        width: 0%;
        background: linear-gradient(90deg, #c45f43, #1d8a6e);
        transition: width 140ms ease;
      }

      .autofill-progress-text {
        margin-top: 5px;
        font-size: 11px;
        color: var(--muted);
      }

      .bulk-view[hidden],
      .detail-view[hidden] {
        display: none !important;
      }

      .bulk-view,
      .detail-view {
        display: flex;
        flex-direction: column;
        height: 100%;
        min-height: 0;
      }

      .bulk-view .table-wrap,
      .detail-view .table-wrap {
        flex: 1;
        min-height: 0;
      }

      .bulk-toolbar {
        padding: 10px 12px 0;
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 10px;
      }

      .bulk-toolbar-note {
        font-size: 12px;
        color: var(--muted);
      }

      .bulk-toolbar-actions {
        display: inline-flex;
        align-items: center;
        gap: 8px;
      }

      .bulk-btn {
        border: 1px solid var(--line);
        border-radius: 8px;
        background: var(--panel-alt);
        color: var(--ink);
        font: inherit;
        font-size: 12px;
        font-weight: 600;
        cursor: pointer;
        padding: 6px 10px;
      }

      .bulk-btn:hover {
        border-color: color-mix(in oklab, var(--brand) 45%, var(--line));
      }

      .bulk-btn:disabled {
        opacity: 0.55;
        cursor: not-allowed;
      }

      .bulk-cell-input {
        width: 100%;
        border: 1px solid var(--line);
        border-radius: 6px;
        background: var(--panel);
        color: var(--ink);
        font: inherit;
        font-size: 12px;
        padding: 6px 7px;
      }

      .bulk-cell-input.readonly {
        background: color-mix(in oklab, var(--panel-alt) 84%, white 16%);
        color: var(--muted);
        border-style: dashed;
      }

      .bulk-grid-wrap {
        min-height: 380px;
      }

      .bulk-hot {
        width: 100%;
      }

      .bulk-hot-message {
        border: 1px dashed var(--line);
        border-radius: 10px;
        padding: 18px;
        color: var(--muted);
        font-size: 13px;
        background: color-mix(in oklab, var(--panel-alt) 78%, white 22%);
      }

      .bulk-hot-message[hidden] {
        display: none !important;
      }

      .hot .htDimmed {
        color: var(--muted);
      }

      .dot {
        width: 8px;
        height: 8px;
        border-radius: 999px;
        background: var(--ok);
        display: inline-block;
        margin-right: 6px;
      }

      .right-pane-content {
        padding: 12px;
        height: calc(100% - 70px);
        overflow: auto;
      }

      .editor-empty {
        border: 1px dashed var(--line);
        border-radius: 12px;
        padding: 22px;
        text-align: center;
        color: var(--muted);
        font-size: 13px;
        margin-top: 10px;
      }

      .editor-head {
        border: 1px solid var(--line);
        background: var(--panel-alt);
        border-radius: 12px;
        padding: 10px 11px;
        margin-bottom: 11px;
      }

      .editor-head-top {
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 10px;
      }

      .editor-file {
        font-size: 12px;
        color: var(--muted);
        margin-bottom: 4px;
      }

      .editor-title {
        font-size: 14px;
        font-weight: 700;
      }

      .editor-clear-btn {
        border: 1px solid color-mix(in oklab, #b53c31 45%, var(--line));
        border-radius: 8px;
        background: color-mix(in oklab, #f9d9d4 75%, white 25%);
        color: color-mix(in oklab, #7f211a 82%, var(--ink));
        font: inherit;
        font-size: 12px;
        font-weight: 600;
        cursor: pointer;
        padding: 6px 9px;
      }

      .editor-clear-btn:hover {
        border-color: color-mix(in oklab, #b53c31 70%, var(--line));
      }

      .field-grid {
        display: grid;
        grid-template-columns: 1fr;
        gap: 10px;
      }

      .field-label {
        display: block;
        font-size: 11px;
        letter-spacing: 0.06em;
        text-transform: uppercase;
        color: var(--muted);
        margin-bottom: 5px;
      }

      .editor-input,
      .editor-select,
      .editor-textarea {
        width: 100%;
        border: 1px solid var(--line);
        border-radius: 9px;
        padding: 8px 9px;
        font: inherit;
        background: var(--panel);
        color: var(--ink);
      }

      .editor-textarea {
        min-height: 78px;
        resize: vertical;
      }

      .field-hint {
        margin-top: 4px;
        font-size: 11px;
        color: var(--muted);
      }

      .field-hint.error {
        color: color-mix(in oklab, #b53c31 82%, var(--ink));
      }

      .editor-inline-row {
        display: grid;
        grid-template-columns: 1fr auto;
        gap: 8px;
        align-items: center;
      }

      .editor-action-btn {
        border: 1px solid var(--line);
        border-radius: 8px;
        background: var(--panel-alt);
        color: var(--ink);
        font: inherit;
        font-size: 12px;
        font-weight: 600;
        cursor: pointer;
        padding: 7px 10px;
        white-space: nowrap;
      }

      .editor-action-btn:hover {
        border-color: color-mix(in oklab, var(--brand) 45%, var(--line));
      }

      .editor-action-btn:disabled {
        opacity: 0.55;
        cursor: not-allowed;
      }

      .recommended-summary {
        border: 1px solid var(--line);
        border-radius: 10px;
        padding: 8px 9px;
        font-size: 12px;
        color: var(--muted);
        background: color-mix(in oklab, var(--panel-alt) 78%, white 22%);
      }

      .field-wrap {
        border: 1px solid transparent;
        border-radius: 10px;
        padding: 7px;
      }

      .field-wrap.recommended {
        border-color: color-mix(in oklab, var(--brand) 45%, var(--line));
        background: color-mix(in oklab, var(--brand-soft) 35%, white 65%);
      }

      .field-wrap.required {
        border-color: color-mix(in oklab, #b53c31 55%, var(--line));
        background: color-mix(in oklab, #f6d4cd 62%, white 38%);
      }

      .required-badge {
        display: inline-flex;
        align-items: center;
        border: 1px solid color-mix(in oklab, #b53c31 55%, var(--line));
        border-radius: 999px;
        padding: 2px 7px;
        margin-left: 6px;
        font-size: 10px;
        letter-spacing: 0.04em;
        text-transform: uppercase;
        color: color-mix(in oklab, #8a2a22 88%, var(--ink));
        background: color-mix(in oklab, #f6d4cd 72%, white 28%);
      }

      .recommended-badge {
        display: inline-flex;
        align-items: center;
        border: 1px solid color-mix(in oklab, var(--brand) 45%, var(--line));
        border-radius: 999px;
        padding: 2px 7px;
        margin-left: 6px;
        font-size: 10px;
        letter-spacing: 0.04em;
        text-transform: uppercase;
        color: color-mix(in oklab, var(--brand) 75%, #5f2c1f);
        background: color-mix(in oklab, var(--brand-soft) 78%, white 22%);
      }

      .authors-list {
        display: flex;
        flex-direction: column;
        gap: 8px;
      }

      .author-row {
        display: grid;
        grid-template-columns: 1fr 1fr auto;
        gap: 8px;
      }

      .author-row button {
        border: 1px solid var(--line);
        border-radius: 8px;
        background: var(--panel-alt);
        color: var(--ink);
        font: inherit;
        cursor: pointer;
        padding: 0 9px;
      }

      .author-row button:hover,
      .author-add-btn:hover {
        border-color: color-mix(in oklab, var(--brand) 40%, var(--line));
      }

      .author-add-btn {
        margin-top: 8px;
        border: 1px solid var(--line);
        border-radius: 9px;
        background: var(--panel-alt);
        color: var(--ink);
        font: inherit;
        font-size: 12px;
        cursor: pointer;
        padding: 7px 10px;
      }

      .apa-preview {
        margin-top: 8px;
        border: 1px dashed var(--line);
        border-radius: 9px;
        padding: 8px 9px;
        font-size: 12px;
        color: var(--muted);
        background: color-mix(in oklab, var(--panel-alt) 75%, white 25%);
      }

      .modal-backdrop {
        position: fixed;
        inset: 0;
        background: rgba(24, 20, 14, 0.46);
        display: flex;
        align-items: center;
        justify-content: center;
        padding: 18px;
        z-index: 50;
      }

      .modal-backdrop[hidden] {
        display: none !important;
      }

      .modal-card {
        width: min(920px, 100%);
        max-height: calc(100vh - 36px);
        overflow: hidden;
        border: 1px solid var(--line);
        border-radius: 14px;
        background: var(--panel);
        box-shadow: 0 18px 40px rgba(44, 42, 36, 0.20);
        display: flex;
        flex-direction: column;
      }

      .modal-head {
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 10px;
        padding: 11px 12px;
        border-bottom: 1px solid var(--line);
      }

      .modal-title {
        margin: 0;
        font-family: "Fraunces", "Iowan Old Style", "Times New Roman", serif;
        font-size: 18px;
      }

      .modal-close {
        border: 1px solid var(--line);
        border-radius: 8px;
        background: var(--panel-alt);
        color: var(--ink);
        font: inherit;
        cursor: pointer;
        padding: 5px 8px;
      }

      .modal-body {
        padding: 10px 12px 14px;
        overflow: auto;
      }

      .modal-note {
        color: var(--muted);
        font-size: 12px;
        margin-bottom: 8px;
      }

      .modal-item {
        border: 1px solid var(--line);
        border-radius: 10px;
        padding: 8px 9px;
        margin-bottom: 8px;
        background: color-mix(in oklab, var(--panel-alt) 73%, white 27%);
      }

      .modal-item-label {
        font-size: 11px;
        color: var(--muted);
        margin-bottom: 5px;
      }

      .modal-item-text {
        margin: 0;
        font-size: 12px;
        white-space: pre-wrap;
        word-break: break-word;
      }

      @media (max-width: 1220px) {
        .app-shell {
          grid-template-columns: 220px 1fr;
          grid-template-rows: 1fr 1fr;
        }
        .right-pane {
          grid-column: 1 / -1;
        }
      }

      @media (max-width: 860px) {
        .app-shell {
          grid-template-columns: 1fr;
          grid-template-rows: auto auto auto;
          height: auto;
          min-height: 100vh;
        }
        .pane {
          min-height: 280px;
        }
      }
    </style>
  </head>
  <body>
    <div class="app-shell" id="appShell">
      <aside class="pane left-pane">
        <div class="pane-header">
          <h1 class="pane-title">Buckets</h1>
          <div class="pane-subtitle">Choose a collection of files</div>
        </div>
        <div class="left-pane-content" id="bucketList"></div>
      </aside>

      <main class="pane main-pane">
        <div class="pane-header">
          <h2 class="pane-title" id="tableTitle">Files</h2>
          <div class="pane-subtitle">Table shows title, year, authors, and journal/book context, plus PDF and text links. If title is empty, filename is used.</div>
          <div class="view-toggle" id="viewToggle">
            <button type="button" class="view-toggle-btn" id="viewToggleBulk">Bulk Edit</button>
            <button type="button" class="view-toggle-btn" id="viewToggleDetail">Detail Edit</button>
          </div>
          <div class="main-tools">
            <button type="button" id="autofillMissingBtn" class="main-action-btn">Autofill Missing Metadata</button>
            <div id="autofillStatus" class="autofill-status">Ready.</div>
          </div>
          <div class="autofill-progress" id="autofillProgress" hidden>
            <div class="autofill-progress-track">
              <div class="autofill-progress-fill" id="autofillProgressFill"></div>
            </div>
            <div class="autofill-progress-text" id="autofillProgressText"></div>
          </div>
        </div>
        <div class="main-pane-body">
          <div class="bulk-view" id="bulkView">
            <div class="bulk-toolbar">
              <div class="bulk-toolbar-note">Paste tabular cells from Excel/Sheets. First two columns (MinIO path, Redis doc id) are read-only.</div>
              <div class="bulk-toolbar-actions">
                <button type="button" class="bulk-btn" id="bulkCopyBtn">Copy TSV</button>
                <button type="button" class="bulk-btn" id="bulkSaveBtn">Save Pending Changes</button>
              </div>
            </div>
            <div class="table-wrap bulk-grid-wrap">
              <div id="bulkHotMessage" class="bulk-hot-message" hidden></div>
              <div id="bulkHot" class="bulk-hot"></div>
            </div>
            <div class="main-footer">
              <div><span class="dot"></span>Bulk edits are local until you press Save Pending Changes</div>
              <div id="bulkStatus">No pending changes.</div>
            </div>
          </div>

          <div class="detail-view" id="detailView" hidden>
            <div class="table-wrap">
              <table>
                <thead>
                  <tr>
                    <th style="width: 30%">
                      <button class="sort-btn" type="button" data-sort-key="title">
                        Title
                        <span class="sort-indicator"></span>
                      </button>
                    </th>
                    <th style="width: 12%">
                      <button class="sort-btn" type="button" data-sort-key="year">
                        Year
                        <span class="sort-indicator"></span>
                      </button>
                    </th>
                    <th style="width: 22%">
                      <button class="sort-btn" type="button" data-sort-key="authors">
                        Authors
                        <span class="sort-indicator"></span>
                      </button>
                    </th>
                    <th style="width: 28%">
                      <button class="sort-btn" type="button" data-sort-key="source">
                        Journal / Book
                        <span class="sort-indicator"></span>
                      </button>
                    </th>
                    <th style="width: 8%; text-align: center"><span class="sr-only">Links</span></th>
                  </tr>
                </thead>
                <tbody id="fileTableBody"></tbody>
              </table>
            </div>
            <div class="main-footer">
              <div><span class="dot"></span>BibTeX metadata autosaves to Redis (prefix: bibtex)</div>
              <div id="selectionHint">Select a file to edit extra BibTeX fields</div>
            </div>
          </div>
        </div>
      </main>

      <aside class="pane right-pane">
        <div class="pane-header">
          <h2 class="pane-title">BibTeX Fields</h2>
          <div class="pane-subtitle">Edit title, year, structured authors, editors, and other metadata for the selected file</div>
        </div>
        <div class="right-pane-content" id="editorPane"></div>
      </aside>
    </div>

    <div class="modal-backdrop" id="dataModal" hidden>
      <div class="modal-card" role="dialog" aria-modal="true" aria-labelledby="dataModalTitle">
        <div class="modal-head">
          <h3 class="modal-title" id="dataModalTitle">Redis Data</h3>
          <button type="button" class="modal-close" id="dataModalClose">Close</button>
        </div>
        <div class="modal-body" id="dataModalBody"></div>
      </div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/handsontable@14.5.0/dist/handsontable.full.min.js"></script>
    <script>
      const entryTypeOptions = [
        "article",
        "book",
        "booklet",
        "conference",
        "inbook",
        "incollection",
        "inproceedings",
        "manual",
        "mastersthesis",
        "misc",
        "phdthesis",
        "proceedings",
        "techreport",
        "unpublished",
      ];

      const fieldConfig = [
        { key: "citationKey", label: "Citation Key", type: "text" },
        {
          key: "entryType",
          label: "Entry Type",
          type: "select",
          options: entryTypeOptions,
        },
        { key: "address", label: "Address", type: "text" },
        { key: "annote", label: "Annote", type: "textarea" },
        { key: "booktitle", label: "Booktitle", type: "text" },
        { key: "chapter", label: "Chapter", type: "text" },
        { key: "crossref", label: "Crossref", type: "text" },
        { key: "doi", label: "DOI", type: "text" },
        { key: "edition", label: "Edition", type: "text" },
        { key: "editors", label: "Editors", type: "text" },
        { key: "howpublished", label: "How Published", type: "text" },
        { key: "institution", label: "Institution", type: "text" },
        { key: "journal", label: "Journal", type: "text" },
        { key: "key", label: "Key", type: "text" },
        { key: "month", label: "Month", type: "text" },
        { key: "note", label: "Note", type: "textarea" },
        { key: "number", label: "Number", type: "text" },
        { key: "organization", label: "Organization", type: "text" },
        { key: "pages", label: "Pages", type: "text" },
        { key: "publisher", label: "Publisher", type: "text" },
        { key: "school", label: "School", type: "text" },
        { key: "series", label: "Series", type: "text" },
        { key: "type", label: "Type", type: "text" },
        { key: "url", label: "URL", type: "text" },
        { key: "volume", label: "Volume", type: "text" },
        { key: "keywords", label: "Keywords", type: "text" },
        { key: "abstract", label: "Abstract", type: "textarea" },
      ];

      const persistFieldKeys = [
        "citationKey",
        "entryType",
        "title",
        "year",
        "authors",
        "address",
        "annote",
        "chapter",
        "crossref",
        "edition",
        "editors",
        "howpublished",
        "institution",
        "journal",
        "key",
        "month",
        "booktitle",
        "organization",
        "publisher",
        "school",
        "series",
        "type",
        "volume",
        "number",
        "pages",
        "doi",
        "url",
        "keywords",
        "abstract",
        "note",
      ];

      const entryTypeRules = {
        article: {
          requiredAll: ["authors", "title", "journal", "year"],
          requiredAny: [],
          recommended: ["volume", "number", "pages", "month", "doi", "url"],
        },
        book: {
          requiredAll: ["title", "publisher", "year"],
          requiredAny: [["authors", "editors"]],
          recommended: ["volume", "number", "series", "address", "edition", "month", "doi", "url"],
        },
        booklet: {
          requiredAll: ["title"],
          requiredAny: [],
          recommended: ["authors", "howpublished", "address", "month", "year", "doi", "url", "note"],
        },
        conference: {
          requiredAll: ["authors", "title", "booktitle", "year"],
          requiredAny: [],
          recommended: ["editors", "volume", "number", "series", "pages", "address", "month", "organization", "publisher", "doi", "url", "note"],
        },
        inbook: {
          requiredAll: ["title", "publisher", "year"],
          requiredAny: [["authors", "editors"], ["chapter", "pages"]],
          recommended: ["volume", "number", "series", "type", "address", "edition", "month", "doi", "url", "note"],
        },
        incollection: {
          requiredAll: ["authors", "title", "booktitle", "publisher", "year"],
          requiredAny: [],
          recommended: ["editors", "volume", "number", "series", "type", "chapter", "pages", "address", "edition", "month", "doi", "url", "note"],
        },
        inproceedings: {
          requiredAll: ["authors", "title", "booktitle", "year"],
          requiredAny: [],
          recommended: ["editors", "volume", "number", "series", "pages", "address", "month", "organization", "publisher", "doi", "url", "note"],
        },
        manual: {
          requiredAll: ["title"],
          requiredAny: [],
          recommended: ["authors", "organization", "address", "edition", "month", "year", "doi", "url", "note"],
        },
        mastersthesis: {
          requiredAll: ["authors", "title", "school", "year"],
          requiredAny: [],
          recommended: ["type", "address", "month", "doi", "url", "note"],
        },
        misc: {
          requiredAll: [],
          requiredAny: [],
          recommended: ["authors", "title", "howpublished", "month", "year", "doi", "url", "note"],
        },
        phdthesis: {
          requiredAll: ["authors", "title", "school", "year"],
          requiredAny: [],
          recommended: ["type", "address", "month", "doi", "url", "note"],
        },
        proceedings: {
          requiredAll: ["title", "year"],
          requiredAny: [],
          recommended: ["editors", "volume", "number", "series", "address", "month", "organization", "publisher", "doi", "url", "note"],
        },
        techreport: {
          requiredAll: ["authors", "title", "institution", "year"],
          requiredAny: [],
          recommended: ["type", "number", "address", "month", "doi", "url", "note"],
        },
        unpublished: {
          requiredAll: ["authors", "title", "note"],
          requiredAny: [],
          recommended: ["month", "year", "doi", "url"],
        },
      };

      const appRequiredFields = ["citationKey", "entryType"];

      const defaultFileFields = {
        citationKey: "",
        entryType: "article",
        title: "",
        year: "",
        authors: [],
        address: "",
        annote: "",
        chapter: "",
        crossref: "",
        edition: "",
        editors: "",
        howpublished: "",
        institution: "",
        journal: "",
        key: "",
        month: "",
        booktitle: "",
        organization: "",
        publisher: "",
        school: "",
        series: "",
        type: "",
        volume: "",
        number: "",
        pages: "",
        doi: "",
        url: "",
        keywords: "",
        abstract: "",
        note: "",
      };

      const bulkColumns = [
        { key: "minioPath", label: "MinIO Path", readOnly: true },
        { key: "redisDocId", label: "Redis Doc ID", readOnly: true },
        { key: "title", label: "Title" },
        { key: "year", label: "Year" },
        { key: "authors", label: "Authors" },
        { key: "address", label: "Address" },
        { key: "annote", label: "Annote" },
        { key: "chapter", label: "Chapter" },
        { key: "crossref", label: "Crossref" },
        { key: "edition", label: "Edition" },
        { key: "editors", label: "Editors" },
        { key: "howpublished", label: "How Published" },
        { key: "institution", label: "Institution" },
        { key: "key", label: "Key" },
        { key: "month", label: "Month" },
        { key: "doi", label: "DOI" },
        { key: "entryType", label: "Entry Type" },
        { key: "journal", label: "Journal" },
        { key: "booktitle", label: "Booktitle" },
        { key: "organization", label: "Organization" },
        { key: "publisher", label: "Publisher" },
        { key: "school", label: "School" },
        { key: "series", label: "Series" },
        { key: "type", label: "Type" },
        { key: "volume", label: "Volume" },
        { key: "number", label: "Number" },
        { key: "pages", label: "Pages" },
        { key: "url", label: "URL" },
        { key: "keywords", label: "Keywords" },
        { key: "note", label: "Note" },
        { key: "abstract", label: "Abstract" },
        { key: "citationKey", label: "Citation Key" },
      ];

      const saveTimers = new Map();
      const saveInFlightByFileId = new Map();
      const autofillBatchSize = 20;
      const selectedBucketCookieName = "mcp_research_selected_bucket";
      const selectedBucketCookieMaxAgeSec = 60 * 60 * 24 * 365;
      const bulkWidthDefaults = { min: 120, max: 420 };
      const bulkWidthByColumn = {
        minioPath: { min: 220, max: 560 },
        redisDocId: { min: 170, max: 320 },
        title: { min: 180, max: 520 },
        authors: { min: 170, max: 420 },
        abstract: { min: 220, max: 560 },
        note: { min: 180, max: 480 },
      };
      const bulkWidthSampleLimit = 250;
      let bulkHot = null;

      const state = {
        viewMode: "detail",
        buckets: [],
        activeBucketId: null,
        activeFileId: null,
        loadingBuckets: false,
        bucketsError: "",
        sort: { key: "title", direction: "asc" },
        saveState: "idle",
        saveFileId: null,
        saveError: "",
        redisSummaryByFile: {},
        redisDetailCache: {},
        bulk: {
          edits: {},
          saving: false,
          status: "No pending changes.",
          error: "",
          rowFileIds: [],
        },
        autofill: {
          running: false,
          bucketId: null,
          total: 0,
          processed: 0,
          counts: {},
          message: "Ready.",
          error: "",
        },
        modal: {
          open: false,
          fileId: null,
          loading: false,
          error: "",
          items: [],
          totalAvailable: 0,
        },
        doiLookup: {
          running: false,
          fileId: null,
          message: "",
          error: "",
        },
      };

      function bucketById(bucketId) {
        return state.buckets.find((bucket) => bucket.id === bucketId) || null;
      }

      function readCookie(name) {
        const source = String(document.cookie || "");
        if (!source) return "";
        const parts = source.split(";");
        for (const part of parts) {
          const [rawName, ...rawValue] = part.trim().split("=");
          if (rawName !== name) continue;
          const value = rawValue.join("=");
          try {
            return decodeURIComponent(value);
          } catch (_error) {
            return value;
          }
        }
        return "";
      }

      function readSelectedBucketCookie() {
        return String(readCookie(selectedBucketCookieName) || "").trim();
      }

      function writeSelectedBucketCookie(bucketId) {
        const value = String(bucketId || "").trim();
        if (!value) return;
        document.cookie =
          `${selectedBucketCookieName}=${encodeURIComponent(value)}; ` +
          `path=/; max-age=${selectedBucketCookieMaxAgeSec}; samesite=lax`;
      }

      function getActiveBucket() {
        return bucketById(state.activeBucketId);
      }

      function getActiveFile() {
        const bucket = getActiveBucket();
        if (!bucket) return null;
        return bucket.files.find((file) => file.id === state.activeFileId) || null;
      }

      function findFileById(fileId) {
        if (!fileId) return null;
        for (const bucket of state.buckets) {
          const file = bucket.files.find((entry) => entry.id === fileId);
          if (file) return file;
        }
        return null;
      }

      function isKnownEntryType(entryType) {
        return Object.prototype.hasOwnProperty.call(entryTypeRules, entryType);
      }

      function entryTypeRule(entryType) {
        const normalized = String(entryType || "").trim().toLowerCase();
        return entryTypeRules[normalized] || entryTypeRules.article;
      }

      function requiredAnyGroupsForEntryType(entryType) {
        return entryTypeRule(entryType).requiredAny || [];
      }

      function requiredSetForEntryType(entryType) {
        const set = new Set(appRequiredFields);
        const rule = entryTypeRule(entryType);
        for (const key of rule.requiredAll || []) {
          set.add(key);
        }
        for (const group of rule.requiredAny || []) {
          for (const key of group) {
            set.add(key);
          }
        }
        return set;
      }

      function recommendedSetForEntryType(entryType) {
        return new Set(entryTypeRule(entryType).recommended || []);
      }

      function displayFieldName(key) {
        if (key === "authors") return "Authors";
        if (key === "editors") return "Editors";
        if (key === "entryType") return "Entry Type";
        if (key === "citationKey") return "Citation Key";
        if (key === "booktitle") return "Booktitle";
        if (key === "howpublished") return "How Published";
        return String(key || "")
          .replace(/([A-Z])/g, " $1")
          .replace(/^./, (char) => char.toUpperCase());
      }

      function createFieldLabel(text, { required = false, recommended = false } = {}) {
        const label = document.createElement("label");
        label.className = "field-label";
        label.textContent = text;
        if (required) {
          const badge = document.createElement("span");
          badge.className = "required-badge";
          badge.textContent = "Required";
          label.append(badge);
        } else if (recommended) {
          const badge = document.createElement("span");
          badge.className = "recommended-badge";
          badge.textContent = "Recommended";
          label.append(badge);
        }
        return label;
      }

      function coerceAuthors(file) {
        if (!Array.isArray(file.authors)) {
          if (typeof file.authors === "string" && file.authors.trim()) {
            const parts = file.authors
              .split(",")
              .map((entry) => entry.trim())
              .filter(Boolean);
            file.authors = parts.map((lastName) => ({ firstName: "", lastName }));
          } else {
            file.authors = [];
          }
        }

        for (let idx = 0; idx < file.authors.length; idx += 1) {
          const author = file.authors[idx];
          if (author && typeof author === "object") {
            let firstName = typeof author.firstName === "string" ? author.firstName : "";
            let lastName = typeof author.lastName === "string" ? author.lastName : "";
            if (!firstName && typeof author.given === "string") firstName = author.given;
            if (!firstName && typeof author.givenName === "string") firstName = author.givenName;
            if (!lastName && typeof author.family === "string") lastName = author.family;
            if (!lastName && typeof author.familyName === "string") lastName = author.familyName;
            if (!firstName && !lastName) {
              const fullName =
                typeof author.name === "string"
                  ? author.name
                  : typeof author.literal === "string"
                    ? author.literal
                    : "";
              const parts = String(fullName)
                .trim()
                .split(/\s+/)
                .filter(Boolean);
              if (parts.length === 1) {
                lastName = parts[0];
              } else if (parts.length > 1) {
                firstName = parts.slice(0, -1).join(" ");
                lastName = parts[parts.length - 1];
              }
            }
            author.firstName = String(firstName || "");
            author.lastName = String(lastName || "");
            continue;
          }
          if (typeof author === "string") {
            file.authors[idx] = { firstName: "", lastName: author };
            continue;
          }
          file.authors[idx] = { firstName: "", lastName: "" };
        }
        return file.authors;
      }

      function hasIncompleteAuthorRows(authors) {
        return (authors || []).some(
          (author) => String(author?.firstName || "").trim() && !String(author?.lastName || "").trim()
        );
      }

      function initialsFromFirstName(firstName) {
        const parts = String(firstName || "")
          .trim()
          .split(/\s+/)
          .filter(Boolean);
        return parts
          .map((part) =>
            part
              .split("-")
              .filter(Boolean)
              .map((subpart) => `${subpart.charAt(0).toUpperCase()}.`)
              .join("-")
          )
          .join(" ");
      }

      function formatAuthorApa(author) {
        const lastName = String(author?.lastName || "").trim();
        const initials = initialsFromFirstName(author?.firstName || "");
        if (lastName && initials) return `${lastName}, ${initials}`;
        if (lastName) return lastName;
        if (initials) return initials;
        return "";
      }

      function formatAuthorsApa(authors) {
        const formatted = authors.map(formatAuthorApa).filter(Boolean);
        if (formatted.length === 0) return "";
        if (formatted.length === 1) return formatted[0];
        if (formatted.length === 2) return `${formatted[0]} & ${formatted[1]}`;
        return `${formatted.slice(0, -1).join(", ")}, & ${formatted[formatted.length - 1]}`;
      }

      function displayTitle(file) {
        return String(file?.title || "").trim() || String(file?.fileName || "").trim() || "â€”";
      }

      function displaySource(file) {
        const entryType = String(file?.entryType || "").trim().toLowerCase();
        const journal = String(file?.journal || "").trim();
        const booktitle = String(file?.booktitle || "").trim();
        const publisher = String(file?.publisher || "").trim();

        if (entryType === "article") return journal || booktitle || publisher;
        if (entryType === "inproceedings" || entryType === "inbook" || entryType === "incollection") {
          return booktitle || journal || publisher;
        }
        if (entryType === "book") return booktitle || publisher || journal;
        return journal || booktitle || publisher;
      }

      function normalizeFileRecord(raw) {
        const file = { ...defaultFileFields, ...(raw || {}) };
        file.bucket = String(file.bucket || "");
        file.objectName = String(file.objectName || "");
        file.fileName = String(file.fileName || file.objectName.split("/").pop() || "unknown");
        file.id = String(file.id || `${file.bucket}/${file.objectName}` || file.fileName);
        if (!Array.isArray(file.redisDocIds)) {
          file.redisDocIds = file.redisDocId ? [String(file.redisDocId)] : [];
        } else {
          file.redisDocIds = file.redisDocIds.map((entry) => String(entry || "")).filter(Boolean);
        }
        file.redisDocId = String(file.redisDocId || file.redisDocIds[0] || "");
        file.entryType = isKnownEntryType(file.entryType) ? file.entryType : "article";
        for (const key of Object.keys(defaultFileFields)) {
          if (key === "authors") continue;
          file[key] = file[key] == null ? "" : String(file[key]);
        }
        coerceAuthors(file);
        return file;
      }

      function setViewMode(mode) {
        if (mode !== "bulk" && mode !== "detail") return;
        if (state.viewMode === "bulk" && mode !== "bulk") {
          finalizeBulkEditing();
        }
        state.viewMode = mode;
        if (mode === "detail") {
          const activeBucket = getActiveBucket();
          if (activeBucket && activeBucket.loaded && !state.activeFileId && activeBucket.files.length > 0) {
            state.activeFileId = activeBucket.files[0].id;
          }
        }
        renderAll();
      }

      function bulkFilesForBucket(bucket) {
        if (!bucket || !Array.isArray(bucket.files)) return [];
        return [...bucket.files].sort((left, right) =>
          String(left.objectName || "").localeCompare(String(right.objectName || ""), undefined, {
            numeric: true,
            sensitivity: "base",
          })
        );
      }

      function bulkFilesForActiveBucket() {
        return bulkFilesForBucket(getActiveBucket());
      }

      function authorsToBulkText(file) {
        const authors = coerceAuthors(file);
        const names = authors
          .map((author) => [author.firstName, author.lastName].filter(Boolean).join(" ").trim())
          .filter(Boolean);
        return names.join("; ");
      }

      function parseBulkAuthors(value) {
        const text = String(value || "").trim();
        if (!text) return [];
        const rawParts = text
          .replace(/\band\b/gi, ";")
          .split(/[;\n]/)
          .map((entry) => entry.trim())
          .filter(Boolean);
        return rawParts.map((entry) => {
          const parts = entry.split(/\s+/).filter(Boolean);
          if (parts.length <= 1) {
            return { firstName: "", lastName: parts[0] || "" };
          }
          return { firstName: parts.slice(0, -1).join(" "), lastName: parts[parts.length - 1] };
        });
      }

      function bulkBaselineValue(file, key) {
        if (key === "minioPath") return `${file.bucket}/${file.objectName}`;
        if (key === "redisDocId") return String(file.redisDocId || "");
        if (key === "authors") return authorsToBulkText(file);
        return String(file?.[key] ?? "");
      }

      function getBulkEditsForFile(fileId) {
        return state.bulk.edits[fileId] || {};
      }

      function getBulkCellValue(file, key) {
        const edits = getBulkEditsForFile(file.id);
        if (Object.prototype.hasOwnProperty.call(edits, key)) {
          return String(edits[key] ?? "");
        }
        return bulkBaselineValue(file, key);
      }

      function updateBulkStatusText() {
        if (state.bulk.saving) {
          return;
        }
        const pendingFiles = Object.keys(state.bulk.edits).length;
        if (pendingFiles === 0) {
          state.bulk.status = "No pending changes.";
          state.bulk.error = "";
          return;
        }
        state.bulk.status = `${pendingFiles} file(s) pending save.`;
      }

      function setBulkCellValue(file, key, value) {
        if (!file || !file.id || key === "minioPath" || key === "redisDocId") return;
        const normalized = String(value ?? "");
        const baseline = bulkBaselineValue(file, key);
        const rowEdits = { ...getBulkEditsForFile(file.id) };
        if (normalized === baseline) {
          delete rowEdits[key];
        } else {
          rowEdits[key] = normalized;
        }

        if (Object.keys(rowEdits).length === 0) {
          delete state.bulk.edits[file.id];
        } else {
          state.bulk.edits[file.id] = rowEdits;
        }
        updateBulkStatusText();
      }

      function destroyBulkHot() {
        if (!bulkHot) return;
        bulkHot.destroy();
        bulkHot = null;
      }

      function finalizeBulkEditing() {
        if (!bulkHot) return;
        const editor = bulkHot.getActiveEditor?.();
        if (editor && editor.isOpened?.()) {
          editor.finishEditing();
        }
      }

      function setBulkHotMessage(message) {
        const messageEl = document.getElementById("bulkHotMessage");
        if (!messageEl) return;
        const text = String(message || "").trim();
        messageEl.hidden = !text;
        messageEl.textContent = text;
      }

      function bulkRowData(file) {
        const row = {};
        for (const column of bulkColumns) {
          row[column.key] = getBulkCellValue(file, column.key);
        }
        return row;
      }

      function clampBulkWidth(value, key) {
        const config = bulkWidthByColumn[key] || bulkWidthDefaults;
        const min = Number(config.min || bulkWidthDefaults.min);
        const max = Number(config.max || bulkWidthDefaults.max);
        return Math.max(min, Math.min(max, value));
      }

      function estimateBulkColumnWidth(key, label, files) {
        const sampleCount = Math.min(files.length, bulkWidthSampleLimit);
        let maxChars = String(label || "").length;
        for (let idx = 0; idx < sampleCount; idx += 1) {
          const file = files[idx];
          const value = String(getBulkCellValue(file, key) || "")
            .replace(/\s+/g, " ")
            .trim();
          if (!value) continue;
          const charCount = Math.min(value.length, 120);
          if (charCount > maxChars) {
            maxChars = charCount;
          }
        }

        const estimatedPixels = Math.round(maxChars * 7.4 + 34);
        return clampBulkWidth(estimatedPixels, key);
      }

      function bulkColumnWidths(files) {
        return bulkColumns.map((column) =>
          estimateBulkColumnWidth(column.key, column.label, files || [])
        );
      }

      function syncBulkEditsFromHotChanges(changes) {
        if (!Array.isArray(changes) || changes.length === 0) return;
        for (const change of changes) {
          const [row, prop, _oldValue, newValue] = change;
          const key = String(prop || "");
          if (!key) continue;
          const column = bulkColumns.find((entry) => entry.key === key);
          if (!column || column.readOnly) continue;
          const fileId = state.bulk.rowFileIds[row];
          const file = findFileById(fileId);
          if (!file) continue;
          setBulkCellValue(file, key, newValue);
        }
      }

      function ensureBulkHot(container) {
        if (bulkHot) return bulkHot;
        const HandsontableLib = window.Handsontable;
        if (!HandsontableLib || !container) return null;

        bulkHot = new HandsontableLib(container, {
          data: [],
          columns: bulkColumns.map((column) => ({
            data: column.key,
            readOnly: !!column.readOnly,
          })),
          colHeaders: bulkColumns.map((column) => column.label),
          colWidths: bulkColumnWidths([]),
          rowHeaders: false,
          width: "100%",
          height: 520,
          stretchH: "none",
          contextMenu: true,
          manualColumnResize: true,
          copyPaste: true,
          autoWrapRow: false,
          autoWrapCol: false,
          licenseKey: "non-commercial-and-evaluation",
          afterChange(changes, source) {
            if (source === "loadData" || source === "updateSettings") return;
            syncBulkEditsFromHotChanges(changes);
            renderBulkStatusAndActions();
          },
        });

        return bulkHot;
      }

      function renderBulkHotGrid(files) {
        const container = document.getElementById("bulkHot");
        if (!container) return;
        const hot = ensureBulkHot(container);
        if (!hot) {
          state.bulk.rowFileIds = [];
          setBulkHotMessage("Handsontable failed to load. Check network access to jsdelivr.");
          return;
        }

        state.bulk.rowFileIds = files.map((file) => file.id);
        const rows = files.map((file) => bulkRowData(file));
        hot.updateSettings({ colWidths: bulkColumnWidths(files) });
        hot.loadData(rows);
      }

      function hasRequiredCoreMetadata(file) {
        if (!file) return false;
        const hasTitle = String(file.title || "").trim().length > 0;
        const hasDoi = String(file.doi || "").trim().length > 0;
        const authors = coerceAuthors(file);
        const hasAuthors = authors.some(
          (author) => String(author.firstName || "").trim() || String(author.lastName || "").trim()
        );
        return hasTitle && hasDoi && hasAuthors;
      }

      function autofillObjectNames(bucket) {
        if (!bucket || !Array.isArray(bucket.files)) return [];
        const names = [];
        for (const file of bucket.files) {
          if (!file?.objectName || hasRequiredCoreMetadata(file)) continue;
          names.push(String(file.objectName));
        }
        return names;
      }

      function resetAutofillState(message = "Ready.") {
        state.autofill.running = false;
        state.autofill.bucketId = null;
        state.autofill.total = 0;
        state.autofill.processed = 0;
        state.autofill.counts = {};
        state.autofill.message = message;
        state.autofill.error = "";
      }

      function applyAutofillResults(bucketId, results) {
        const bucket = bucketById(bucketId);
        if (!bucket || !Array.isArray(results)) return;
        for (const item of results) {
          const objectName = String(item?.objectName || "");
          const incomingFile = item?.file;
          if (!objectName || !incomingFile) continue;
          const idx = bucket.files.findIndex((file) => file.objectName === objectName);
          if (idx < 0) continue;
          bucket.files[idx] = normalizeFileRecord(incomingFile);
        }
      }

      function mergeAutofillCounts(counts) {
        if (!counts || typeof counts !== "object") return;
        for (const [key, value] of Object.entries(counts)) {
          const numericValue = Number(value || 0);
          state.autofill.counts[key] = Number(state.autofill.counts[key] || 0) + numericValue;
        }
      }

      async function runAutofillMissing() {
        const bucket = getActiveBucket();
        if (!bucket || bucket.loading || state.autofill.running) return;
        const targetObjectNames = autofillObjectNames(bucket);
        resetAutofillState();
        state.autofill.bucketId = bucket.id;
        state.autofill.total = targetObjectNames.length;
        state.autofill.message = "Preparing autofill run...";
        renderAll();

        if (targetObjectNames.length === 0) {
          state.autofill.message = "No files with missing core metadata.";
          renderAll();
          return;
        }

        state.autofill.running = true;
        state.autofill.message = "Running autofill in batches...";
        renderAll();

        let offset = 0;
        while (offset < targetObjectNames.length) {
          try {
            const data = await apiRequest(`/api/buckets/${encodeURIComponent(bucket.id)}/autofill-missing`, {
              method: "POST",
              body: JSON.stringify({
                objectNames: targetObjectNames,
                offset,
                batchSize: autofillBatchSize,
                dryRun: false,
              }),
            });
            offset = Number(data.next_offset ?? data.processed_total ?? targetObjectNames.length);
            state.autofill.processed = Number(data.processed_total || offset);
            mergeAutofillCounts(data.counts || {});
            applyAutofillResults(bucket.id, data.results || []);
            state.autofill.message = `Processed ${state.autofill.processed} of ${state.autofill.total}.`;
            renderAll();
          } catch (error) {
            state.autofill.error = String(error.message || error);
            state.autofill.message = `Autofill failed: ${state.autofill.error}`;
            break;
          }
        }

        state.autofill.running = false;
        if (!state.autofill.error) {
          const updatedCount = Number(state.autofill.counts.updated || 0);
          const skippedCount = Number(state.autofill.counts.skipped_existing || 0);
          const lowConfidenceCount = Number(state.autofill.counts.low_confidence || 0);
          const conflictCount = Number(state.autofill.counts.doi_conflict || 0);
          state.autofill.message =
            `Done. Updated ${updatedCount} file(s), skipped ${skippedCount}, low confidence ${lowConfidenceCount}, DOI conflicts ${conflictCount}.`;
        }
        renderAll();
      }

      async function apiRequest(path, options = {}) {
        const requestOptions = {
          ...options,
          headers: {
            "Content-Type": "application/json",
            ...(options.headers || {}),
          },
        };
        const response = await fetch(path, requestOptions);
        const text = await response.text();
        let payload = null;
        if (text) {
          try {
            payload = JSON.parse(text);
          } catch (_err) {
            payload = null;
          }
        }
        if (!response.ok) {
          const detail = payload?.detail || text || `HTTP ${response.status}`;
          throw new Error(detail);
        }
        return payload || {};
      }

      function encodeObjectPath(objectName) {
        return String(objectName)
          .split("/")
          .map((part) => encodeURIComponent(part))
          .join("/");
      }

      function sortValueForFile(file, key) {
        if (key === "authors") {
          return formatAuthorsApa(coerceAuthors(file));
        }
        if (key === "title") {
          return displayTitle(file);
        }
        if (key === "source") {
          return displaySource(file);
        }
        const value = file[key];
        return value == null ? "" : String(value);
      }

      function compareSortValues(left, right, key) {
        if (key === "year") {
          const leftNum = Number.parseInt(left, 10);
          const rightNum = Number.parseInt(right, 10);
          const leftIsNum = Number.isFinite(leftNum);
          const rightIsNum = Number.isFinite(rightNum);
          if (leftIsNum && rightIsNum) {
            return leftNum - rightNum;
          }
          if (leftIsNum) return -1;
          if (rightIsNum) return 1;
        }
        return left.localeCompare(right, undefined, { numeric: true, sensitivity: "base" });
      }

      function sortFiles(files) {
        const { key, direction } = state.sort;
        const sorted = [...files].sort((leftFile, rightFile) => {
          const left = sortValueForFile(leftFile, key);
          const right = sortValueForFile(rightFile, key);
          let result = compareSortValues(left, right, key);
          if (result === 0) {
            result = sortValueForFile(leftFile, "fileName").localeCompare(
              sortValueForFile(rightFile, "fileName"),
              undefined,
              { numeric: true, sensitivity: "base" }
            );
          }
          return direction === "asc" ? result : -result;
        });
        return sorted;
      }

      function updateSortIndicators() {
        const buttons = document.querySelectorAll(".sort-btn");
        for (const button of buttons) {
          const key = button.dataset.sortKey;
          const active = key === state.sort.key;
          button.classList.toggle("active", active);
          const indicator = button.querySelector(".sort-indicator");
          if (!indicator) continue;
          indicator.textContent = active ? (state.sort.direction === "asc" ? "â–²" : "â–¼") : "â†•";
        }
      }

      function setSort(key) {
        if (state.sort.key === key) {
          state.sort.direction = state.sort.direction === "asc" ? "desc" : "asc";
        } else {
          state.sort.key = key;
          state.sort.direction = "asc";
        }
        renderAll();
      }

      function initSortControls() {
        const buttons = document.querySelectorAll(".sort-btn");
        for (const button of buttons) {
          button.addEventListener("click", () => {
            setSort(button.dataset.sortKey);
          });
        }
      }

      function initViewToggleControls() {
        const bulkBtn = document.getElementById("viewToggleBulk");
        const detailBtn = document.getElementById("viewToggleDetail");
        if (bulkBtn) {
          bulkBtn.addEventListener("click", () => setViewMode("bulk"));
        }
        if (detailBtn) {
          detailBtn.addEventListener("click", () => setViewMode("detail"));
        }
      }

      function renderAutofillControls() {
        const button = document.getElementById("autofillMissingBtn");
        const status = document.getElementById("autofillStatus");
        const progressWrap = document.getElementById("autofillProgress");
        const progressFill = document.getElementById("autofillProgressFill");
        const progressText = document.getElementById("autofillProgressText");
        if (!button || !status || !progressWrap || !progressFill || !progressText) return;

        const activeBucket = getActiveBucket();
        const ready = !!activeBucket && activeBucket.loaded && !activeBucket.loading;
        button.disabled = !ready || state.autofill.running;
        button.textContent = state.autofill.running ? "Autofilling..." : "Autofill Missing Metadata";
        status.textContent = state.autofill.message || "Ready.";

        const total = Number(state.autofill.total || 0);
        const processed = Number(state.autofill.processed || 0);
        const hasProgress = total > 0 || state.autofill.running;
        progressWrap.hidden = !hasProgress;
        if (!hasProgress) {
          progressFill.style.width = "0%";
          progressText.textContent = "";
          return;
        }

        const percent = total > 0 ? Math.min(100, Math.round((processed / total) * 100)) : 0;
        progressFill.style.width = `${percent}%`;
        const updated = Number(state.autofill.counts.updated || 0);
        const skipped = Number(state.autofill.counts.skipped_existing || 0);
        const lowConfidence = Number(state.autofill.counts.low_confidence || 0);
        const conflicts = Number(state.autofill.counts.doi_conflict || 0);
        const failed = Number(state.autofill.counts.error || 0);
        progressText.textContent =
          `${processed}/${total} â€¢ ${percent}% â€¢ updated ${updated} â€¢ skipped ${skipped} â€¢ low confidence ${lowConfidence} â€¢ DOI conflicts ${conflicts} â€¢ errors ${failed}`;
      }

      function initAutofillControls() {
        const button = document.getElementById("autofillMissingBtn");
        if (!button) return;
        button.addEventListener("click", () => {
          runAutofillMissing();
        });
      }

      function initBulkControls() {
        const copyBtn = document.getElementById("bulkCopyBtn");
        const saveBtn = document.getElementById("bulkSaveBtn");
        if (copyBtn) {
          copyBtn.addEventListener("click", () => {
            copyBulkTsv();
          });
        }
        if (saveBtn) {
          saveBtn.addEventListener("click", () => {
            saveBulkChanges();
          });
        }
      }

      function redisSummaryForFile(file) {
        if (!file) return null;
        return state.redisSummaryByFile[file.id] || null;
      }

      async function ensureRedisSummary(file) {
        if (!file || !file.bucket || !file.objectName) return;
        const existing = redisSummaryForFile(file);
        if (existing && (existing.status === "loading" || existing.status === "loaded")) {
          return;
        }

        state.redisSummaryByFile[file.id] = {
          status: "loading",
          partitionCount: 0,
          docIds: [],
          sourcePrefix: "",
          error: "",
        };

        try {
          const data = await apiRequest(
            `/api/buckets/${encodeURIComponent(file.bucket)}/files/${encodeObjectPath(file.objectName)}/redis-summary`
          );
          state.redisSummaryByFile[file.id] = {
            status: "loaded",
            partitionCount: Number(data.partition_count || 0),
            docIds: Array.isArray(data.doc_ids) ? data.doc_ids : [],
            sourcePrefix: String(data.source_prefix || ""),
            error: "",
          };
        } catch (error) {
          state.redisSummaryByFile[file.id] = {
            status: "error",
            partitionCount: 0,
            docIds: [],
            sourcePrefix: "",
            error: String(error.message || error),
          };
        }
        renderAll();
      }

      function modalCacheKey(file) {
        return file.id;
      }

      async function openRedisModal(file) {
        if (!file || !file.bucket || !file.objectName) return;

        state.modal.open = true;
        state.modal.fileId = file.id;
        state.modal.loading = true;
        state.modal.error = "";
        state.modal.items = [];
        state.modal.totalAvailable = 0;
        renderModal();

        const cacheKey = modalCacheKey(file);
        if (state.redisDetailCache[cacheKey]) {
          const cached = state.redisDetailCache[cacheKey];
          state.modal.loading = false;
          state.modal.error = "";
          state.modal.items = cached.items || [];
          state.modal.totalAvailable = Number(cached.totalAvailable || 0);
          renderModal();
          return;
        }

        try {
          const data = await apiRequest(
            `/api/buckets/${encodeURIComponent(file.bucket)}/files/${encodeObjectPath(file.objectName)}/redis-data?kind=partitions&limit=250`
          );
          const payload = {
            items: Array.isArray(data.items) ? data.items : [],
            totalAvailable: Number(data.total_available || 0),
          };
          state.redisDetailCache[cacheKey] = payload;
          state.modal.loading = false;
          state.modal.error = "";
          state.modal.items = payload.items;
          state.modal.totalAvailable = payload.totalAvailable;
        } catch (error) {
          state.modal.loading = false;
          state.modal.error = String(error.message || error);
          state.modal.items = [];
          state.modal.totalAvailable = 0;
        }
        renderModal();
      }

      function closeDataModal() {
        state.modal.open = false;
        state.modal.loading = false;
        state.modal.error = "";
        state.modal.items = [];
        state.modal.totalAvailable = 0;
        renderModal();
      }

      function renderModal() {
        const modal = document.getElementById("dataModal");
        const modalTitle = document.getElementById("dataModalTitle");
        const modalBody = document.getElementById("dataModalBody");
        if (!modal || !modalTitle || !modalBody) return;

        if (!state.modal.open) {
          modal.hidden = true;
          modalBody.innerHTML = "";
          return;
        }

        const file = findFileById(state.modal.fileId) || getActiveFile();
        const fileLabel = file ? file.fileName : "File";
        modalTitle.textContent = `Partition Markdown - ${fileLabel}`;
        modal.hidden = false;
        modalBody.innerHTML = "";

        const note = document.createElement("div");
        note.className = "modal-note";
        modalBody.append(note);

        if (state.modal.loading) {
          note.textContent = "Loading Redis data...";
          return;
        }

        if (state.modal.error) {
          note.textContent = `Error: ${state.modal.error}`;
          return;
        }

        const loadedCount = state.modal.items.length;
        note.textContent = `Loaded ${loadedCount} item(s)` +
          (state.modal.totalAvailable > loadedCount ? ` of ${state.modal.totalAvailable} (lazy loaded)` : "") +
          ".";

        if (loadedCount === 0) {
          const empty = document.createElement("div");
          empty.className = "modal-note";
          empty.textContent = "No text entries found for this file.";
          modalBody.append(empty);
          return;
        }

        for (const item of state.modal.items) {
          const wrap = document.createElement("div");
          wrap.className = "modal-item";

          const label = document.createElement("div");
          label.className = "modal-item-label";
          label.textContent = item.label || "Entry";

          const text = document.createElement("pre");
          text.className = "modal-item-text";
          text.textContent = item.text || "";

          wrap.append(label, text);
          modalBody.append(wrap);
        }
      }

      function initModalControls() {
        const modal = document.getElementById("dataModal");
        const closeBtn = document.getElementById("dataModalClose");
        if (closeBtn) {
          closeBtn.addEventListener("click", closeDataModal);
        }
        if (modal) {
          modal.addEventListener("click", (event) => {
            if (event.target === modal) {
              closeDataModal();
            }
          });
        }
      }

      async function loadBuckets() {
        state.loadingBuckets = true;
        state.bucketsError = "";
        renderAll();
        try {
          const data = await apiRequest("/api/buckets");
          const names = Array.isArray(data.buckets) ? data.buckets : [];
          state.buckets = names.map((name) => ({
            id: name,
            name,
            files: [],
            loaded: false,
            loading: false,
            error: "",
          }));
          const hasActiveSelection = state.buckets.some((bucket) => bucket.id === state.activeBucketId);
          if (!hasActiveSelection) {
            const persistedBucketId = readSelectedBucketCookie();
            const hasPersistedSelection = state.buckets.some((bucket) => bucket.id === persistedBucketId);
            state.activeBucketId = hasPersistedSelection
              ? persistedBucketId
              : state.buckets.length > 0
                ? state.buckets[0].id
                : null;
            state.activeFileId = null;
          }
          writeSelectedBucketCookie(state.activeBucketId);
          renderAll();
          if (state.buckets.length > 0) {
            await Promise.allSettled(state.buckets.map((bucket) => ensureBucketLoaded(bucket.id)));
          }
        } catch (error) {
          state.buckets = [];
          state.activeBucketId = null;
          state.activeFileId = null;
          state.bucketsError = String(error.message || error);
          renderAll();
        } finally {
          state.loadingBuckets = false;
          renderBuckets();
        }
      }

      async function ensureBucketLoaded(bucketId) {
        const bucket = bucketById(bucketId);
        if (!bucket || bucket.loaded || bucket.loading) {
          return;
        }
        bucket.loading = true;
        bucket.error = "";
        renderAll();
        try {
          const data = await apiRequest(`/api/buckets/${encodeURIComponent(bucketId)}/files`);
          const files = Array.isArray(data.files) ? data.files : [];
          bucket.files = files.map(normalizeFileRecord);
          bucket.loaded = true;
          if (state.activeBucketId === bucketId) {
            const hasActive = bucket.files.some((file) => file.id === state.activeFileId);
            if (!hasActive) {
              state.activeFileId = bucket.files.length > 0 ? bucket.files[0].id : null;
            }
          }
        } catch (error) {
          bucket.loaded = true;
          bucket.files = [];
          bucket.error = String(error.message || error);
          if (state.activeBucketId === bucketId) {
            state.activeFileId = null;
          }
        } finally {
          bucket.loading = false;
          renderAll();
        }
      }

      function selectBucket(bucketId) {
        state.activeBucketId = bucketId;
        state.activeFileId = null;
        writeSelectedBucketCookie(bucketId);
        if (!state.autofill.running) {
          resetAutofillState();
        }
        updateBulkStatusText();
        renderAll();
        ensureBucketLoaded(bucketId);
      }

      function selectFile(fileId) {
        state.activeFileId = fileId;
        renderAll();
      }

      function buildSavePayload(file) {
        const payload = {};
        for (const key of persistFieldKeys) {
          if (key === "authors") {
            payload[key] = coerceAuthors(file);
          } else {
            payload[key] = file[key] == null ? "" : file[key];
          }
        }
        return payload;
      }

      async function persistFileMetadata(file) {
        const data = await apiRequest(
          `/api/buckets/${encodeURIComponent(file.bucket)}/files/${encodeObjectPath(file.objectName)}/bibtex`,
          {
            method: "PUT",
            body: JSON.stringify(buildSavePayload(file)),
          }
        );
        return normalizeFileRecord(data.file || {});
      }

      async function saveFile(file) {
        if (!file || !file.bucket || !file.objectName) {
          return;
        }
        const priorSave = saveInFlightByFileId.get(file.id);
        if (priorSave) {
          try {
            await priorSave;
          } catch (_error) {
            // Continue and allow the latest save attempt.
          }
        }

        const savePromise = (async () => {
          state.saveState = "saving";
          state.saveFileId = file.id;
          state.saveError = "";
          renderTable();
          try {
            const saved = await persistFileMetadata(file);
            Object.assign(file, saved);
            state.saveState = "saved";
            state.saveFileId = file.id;
            state.saveError = "";
          } catch (error) {
            state.saveState = "error";
            state.saveFileId = file.id;
            state.saveError = String(error.message || error);
          }
          renderAll();
        })();

        saveInFlightByFileId.set(file.id, savePromise);
        try {
          await savePromise;
        } finally {
          if (saveInFlightByFileId.get(file.id) === savePromise) {
            saveInFlightByFileId.delete(file.id);
          }
        }
      }

      async function lookupByDoiForFile(file) {
        if (!file || !file.bucket || !file.objectName || state.doiLookup.running) return;
        const doi = String(file.doi || "").trim();
        if (!doi) return;

        const confirmed = window.confirm(
          "DOI lookup will overwrite existing metadata for this file with CrossRef values. Continue?"
        );
        if (!confirmed) return;

        cancelScheduledSave(file.id);
        const pendingSave = saveInFlightByFileId.get(file.id);
        if (pendingSave) {
          try {
            await pendingSave;
          } catch (_error) {
            // Lookup can still proceed even if a prior autosave failed.
          }
        }
        state.doiLookup.running = true;
        state.doiLookup.fileId = file.id;
        state.doiLookup.message = "Looking up DOI via CrossRef...";
        state.doiLookup.error = "";
        renderEditor();

        try {
          const data = await apiRequest(
            `/api/buckets/${encodeURIComponent(file.bucket)}/files/${encodeObjectPath(file.objectName)}/lookup-by-doi`,
            {
              method: "POST",
              body: JSON.stringify({ doi, overwrite: true }),
            }
          );
          const updated = normalizeFileRecord(data.file || {});
          Object.assign(file, updated);
          state.doiLookup.running = false;
          state.doiLookup.fileId = file.id;
          state.doiLookup.error = "";
          state.doiLookup.message = "CrossRef metadata applied.";
          renderAll();
        } catch (error) {
          state.doiLookup.running = false;
          state.doiLookup.fileId = file.id;
          state.doiLookup.error = String(error.message || error);
          state.doiLookup.message = "";
          renderEditor();
        }
      }

      function applyBulkEditsToDraft(file, edits) {
        const draft = normalizeFileRecord({ ...file });
        for (const [key, value] of Object.entries(edits || {})) {
          if (key === "minioPath" || key === "redisDocId") continue;
          if (key === "authors") {
            draft.authors = parseBulkAuthors(value);
            continue;
          }
          if (key === "entryType") {
            const normalized = String(value || "").trim().toLowerCase();
            draft.entryType = isKnownEntryType(normalized) ? normalized : "article";
            continue;
          }
          draft[key] = String(value ?? "");
        }
        return draft;
      }

      async function saveBulkChanges() {
        finalizeBulkEditing();
        const pendingEntries = Object.entries(state.bulk.edits);
        if (pendingEntries.length === 0) {
          state.bulk.status = "No pending changes.";
          state.bulk.error = "";
          renderBulkView();
          return;
        }

        state.bulk.saving = true;
        state.bulk.error = "";
        state.bulk.status = `Saving ${pendingEntries.length} file(s)...`;
        renderBulkView();

        let savedCount = 0;
        let failedCount = 0;
        for (const [fileId, edits] of pendingEntries) {
          const file = findFileById(fileId);
          if (!file) {
            delete state.bulk.edits[fileId];
            continue;
          }
          const draft = applyBulkEditsToDraft(file, edits);
          try {
            const saved = await persistFileMetadata(draft);
            Object.assign(file, saved);
            delete state.bulk.edits[fileId];
            savedCount += 1;
          } catch (error) {
            failedCount += 1;
            state.bulk.error = String(error.message || error);
          }
        }

        state.bulk.saving = false;
        if (failedCount > 0) {
          const remaining = Object.keys(state.bulk.edits).length;
          state.bulk.status = `Saved ${savedCount}; ${failedCount} failed. ${remaining} file(s) still pending.`;
        } else {
          state.bulk.status = `Saved ${savedCount} file(s).`;
          updateBulkStatusText();
        }
        renderAll();
      }

      async function copyBulkTsv() {
        finalizeBulkEditing();
        const files = bulkFilesForActiveBucket();
        if (files.length === 0) {
          state.bulk.status = "No rows to copy.";
          renderBulkView();
          return;
        }

        const lines = [];
        lines.push(bulkColumns.map((column) => column.label).join("\t"));
        for (const file of files) {
          const row = bulkColumns.map((column) => getBulkCellValue(file, column.key));
          lines.push(row.join("\t"));
        }
        const text = lines.join("\n");
        try {
          await navigator.clipboard.writeText(text);
          state.bulk.status = `Copied ${files.length} row(s) to clipboard.`;
          state.bulk.error = "";
        } catch (error) {
          state.bulk.status = "Clipboard copy failed.";
          state.bulk.error = String(error.message || error);
        }
        renderBulkView();
      }

      function cancelScheduledSave(fileId) {
        const existingTimer = saveTimers.get(fileId);
        if (!existingTimer) return;
        clearTimeout(existingTimer);
        saveTimers.delete(fileId);
      }

      function scheduleSave(file) {
        if (!file) return;
        state.saveState = "pending";
        state.saveFileId = file.id;
        state.saveError = "";
        renderTable();
        cancelScheduledSave(file.id);
        const timer = setTimeout(() => {
          saveTimers.delete(file.id);
          saveFile(file);
        }, 500);
        saveTimers.set(file.id, timer);
      }

      async function clearSelectedFileMetadata(file) {
        if (!file) return;
        const confirmed = window.confirm(`Clear metadata for "${file.fileName}"?`);
        if (!confirmed) return;

        cancelScheduledSave(file.id);
        for (const key of Object.keys(defaultFileFields)) {
          if (key === "authors") {
            file.authors = [];
            continue;
          }
          file[key] = defaultFileFields[key];
        }

        renderTable();
        renderEditor();
        await saveFile(file);
      }

      function renderBuckets() {
        const bucketList = document.getElementById("bucketList");
        bucketList.innerHTML = "";

        if (state.loadingBuckets && state.buckets.length === 0) {
          const loading = document.createElement("div");
          loading.className = "pane-subtitle";
          loading.textContent = "Loading buckets...";
          bucketList.append(loading);
          return;
        }

        if (state.bucketsError) {
          const error = document.createElement("div");
          error.className = "pane-subtitle";
          error.textContent = `Error: ${state.bucketsError}`;
          bucketList.append(error);
        }

        if (state.buckets.length === 0 && !state.bucketsError) {
          const empty = document.createElement("div");
          empty.className = "pane-subtitle";
          empty.textContent = "No buckets configured.";
          bucketList.append(empty);
          return;
        }

        for (const bucket of state.buckets) {
          const button = document.createElement("button");
          button.className = "bucket-btn" + (bucket.id === state.activeBucketId ? " active" : "");
          button.type = "button";
          button.addEventListener("click", () => selectBucket(bucket.id));

          const name = document.createElement("span");
          name.className = "bucket-name";
          name.textContent = bucket.name;

          const count = document.createElement("span");
          count.className = "bucket-count";
          count.textContent = bucket.loading ? "..." : String(bucket.files.length);

          button.append(name, count);
          bucketList.append(button);
        }
      }

      function selectionHintText(activeFile) {
        if (!activeFile) {
          return "Select a file to edit metadata";
        }
        let text = `Selected: ${activeFile.fileName}`;
        if (state.saveFileId === activeFile.id) {
          if (state.saveState === "pending") text += " â€¢ Save queued...";
          if (state.saveState === "saving") text += " â€¢ Saving to Redis...";
          if (state.saveState === "saved") text += " â€¢ Saved to Redis";
          if (state.saveState === "error") text += ` â€¢ Save failed: ${state.saveError}`;
        }
        return text;
      }

      function renderViewToggle() {
        const bulkBtn = document.getElementById("viewToggleBulk");
        const detailBtn = document.getElementById("viewToggleDetail");
        if (!bulkBtn || !detailBtn) return;
        bulkBtn.classList.toggle("active", state.viewMode === "bulk");
        detailBtn.classList.toggle("active", state.viewMode === "detail");
      }

      function renderLayoutMode() {
        const appShell = document.getElementById("appShell");
        const bulkView = document.getElementById("bulkView");
        const detailView = document.getElementById("detailView");
        if (appShell) {
          appShell.classList.toggle("bulk-mode", state.viewMode === "bulk");
        }
        if (bulkView) {
          bulkView.hidden = state.viewMode !== "bulk";
        }
        if (detailView) {
          detailView.hidden = state.viewMode !== "detail";
        }
        if (state.viewMode !== "bulk") {
          destroyBulkHot();
          state.bulk.rowFileIds = [];
        }
      }

      function renderBulkStatusAndActions() {
        const status = document.getElementById("bulkStatus");
        const copyBtn = document.getElementById("bulkCopyBtn");
        const saveBtn = document.getElementById("bulkSaveBtn");
        const activeBucket = getActiveBucket();
        const fileCount = bulkFilesForActiveBucket().length;
        const pendingCount = Object.keys(state.bulk.edits).length;
        if (status) {
          const errorText = state.bulk.error ? ` Error: ${state.bulk.error}` : "";
          status.textContent = `${state.bulk.status || "No pending changes."}${errorText}`;
        }
        if (copyBtn) {
          copyBtn.disabled = state.bulk.saving || !activeBucket || activeBucket.loading || fileCount === 0;
        }
        if (saveBtn) {
          saveBtn.disabled = state.bulk.saving || pendingCount === 0;
          saveBtn.textContent = state.bulk.saving ? "Saving..." : "Save Pending Changes";
        }
      }

      function renderBulkView() {
        const title = document.getElementById("tableTitle");
        if (!title) return;

        const activeBucket = getActiveBucket();
        title.textContent = activeBucket ? `Bulk Edit in ${activeBucket.name}` : "Bulk Edit";

        if (state.loadingBuckets && state.buckets.length === 0) {
          setBulkHotMessage("Loading buckets...");
          renderBulkHotGrid([]);
          renderBulkStatusAndActions();
          return;
        }

        if (state.bucketsError) {
          setBulkHotMessage(`Error: ${state.bucketsError}`);
          renderBulkHotGrid([]);
          renderBulkStatusAndActions();
          return;
        }

        if (!activeBucket) {
          setBulkHotMessage("No bucket selected.");
          renderBulkHotGrid([]);
          renderBulkStatusAndActions();
          return;
        }

        if (activeBucket.loading) {
          setBulkHotMessage("Loading files...");
          renderBulkHotGrid([]);
          renderBulkStatusAndActions();
          return;
        }

        if (activeBucket.error) {
          setBulkHotMessage(`Error: ${activeBucket.error}`);
          renderBulkHotGrid([]);
          renderBulkStatusAndActions();
          return;
        }

        const files = bulkFilesForActiveBucket();
        if (files.length === 0) {
          setBulkHotMessage("No files available in this bucket.");
          renderBulkHotGrid([]);
          renderBulkStatusAndActions();
          return;
        }

        setBulkHotMessage("");
        renderBulkHotGrid(files);
        renderBulkStatusAndActions();
      }

      function renderTable() {
        const activeBucket = getActiveBucket();
        const activeFile = getActiveFile();
        const title = document.getElementById("tableTitle");
        const hint = document.getElementById("selectionHint");
        const body = document.getElementById("fileTableBody");
        updateSortIndicators();

        if (state.loadingBuckets && state.buckets.length === 0) {
          title.textContent = "Files";
          hint.textContent = "Loading buckets...";
          body.innerHTML = '<tr><td colspan="5">Loading buckets...</td></tr>';
          return;
        }

        if (state.bucketsError) {
          title.textContent = "Files";
          hint.textContent = "Unable to load data";
          body.innerHTML = `<tr><td colspan="5">Error: ${state.bucketsError}</td></tr>`;
          return;
        }

        if (!activeBucket) {
          title.textContent = "Files";
          hint.textContent = "No bucket selected";
          body.innerHTML = '<tr><td colspan="5">No files available.</td></tr>';
          return;
        }

        title.textContent = `Files in ${activeBucket.name}`;
        hint.textContent = selectionHintText(activeFile);
        body.innerHTML = "";

        if (activeBucket.loading) {
          body.innerHTML = '<tr><td colspan="5">Loading files...</td></tr>';
          return;
        }

        if (activeBucket.error) {
          body.innerHTML = `<tr><td colspan="5">Error: ${activeBucket.error}</td></tr>`;
          return;
        }

        if (activeBucket.files.length === 0) {
          body.innerHTML = '<tr><td colspan="5">No matching files in this bucket.</td></tr>';
          return;
        }

        const sortedFiles = sortFiles(activeBucket.files);
        for (const file of sortedFiles) {
          const row = document.createElement("tr");
          if (file.id === state.activeFileId) {
            row.classList.add("active");
          }
          row.addEventListener("click", () => selectFile(file.id));

          const titleCell = document.createElement("td");
          titleCell.className = "file-name";
          titleCell.textContent = displayTitle(file);
          row.append(titleCell);

          const yearCell = document.createElement("td");
          yearCell.textContent = file.year || "â€”";
          row.append(yearCell);

          const authorsCell = document.createElement("td");
          const authors = coerceAuthors(file);
          authorsCell.textContent = formatAuthorsApa(authors) || "â€”";
          row.append(authorsCell);

          const sourceCell = document.createElement("td");
          sourceCell.textContent = displaySource(file) || "â€”";
          row.append(sourceCell);

          const linkCell = document.createElement("td");
          linkCell.className = "pdf-cell";
          const actions = document.createElement("div");
          actions.className = "file-actions";
          if (file.originalFileUrl) {
            const link = document.createElement("a");
            link.href = file.originalFileUrl;
            link.className = "file-link";
            link.title = "Open PDF";
            link.setAttribute("aria-label", "Open PDF");
            link.innerHTML =
              '<span class="file-action-chip file-action-chip-pdf" aria-hidden="true">PDF</span>';
            link.target = "_blank";
            link.rel = "noopener noreferrer";
            link.addEventListener("click", (event) => event.stopPropagation());
            actions.append(link);
          }
          const textBtn = document.createElement("button");
          textBtn.type = "button";
          textBtn.className = "file-link icon-btn";
          textBtn.title = "View partition markdown";
          textBtn.setAttribute("aria-label", "View partition markdown");
          textBtn.disabled = !file.bucket || !file.objectName;
          textBtn.innerHTML =
            '<span class="file-action-chip file-action-chip-md" aria-hidden="true">MD</span>';
          textBtn.addEventListener("click", (event) => {
            event.stopPropagation();
            openRedisModal(file);
          });
          actions.append(textBtn);

          if (actions.childElementCount > 0) {
            linkCell.append(actions);
          } else {
            linkCell.textContent = "â€”";
          }
          row.append(linkCell);

          body.append(row);
        }
      }

      function renderEditor() {
        const pane = document.getElementById("editorPane");
        const file = getActiveFile();
        if (!file) {
          pane.innerHTML = '<div class="editor-empty">Select a file row to edit BibTeX metadata fields.</div>';
          return;
        }

        pane.innerHTML = "";

        const header = document.createElement("div");
        header.className = "editor-head";

        const fileTag = document.createElement("div");
        fileTag.className = "editor-file";
        fileTag.textContent = file.fileName;

        const headerTitle = document.createElement("div");
        headerTitle.className = "editor-title";
        headerTitle.textContent = file.title || "Untitled";

        const fileInfo = document.createElement("div");
        fileInfo.append(fileTag, headerTitle);

        const headerTop = document.createElement("div");
        headerTop.className = "editor-head-top";
        headerTop.append(fileInfo);

        const clearBtn = document.createElement("button");
        clearBtn.type = "button";
        clearBtn.className = "editor-clear-btn";
        clearBtn.textContent = "Clear Metadata";
        clearBtn.addEventListener("click", () => {
          clearSelectedFileMetadata(file);
        });
        headerTop.append(clearBtn);

        header.append(headerTop);
        pane.append(header);

        const grid = document.createElement("div");
        grid.className = "field-grid";

        const requiredSet = requiredSetForEntryType(file.entryType);
        const recommendedSet = recommendedSetForEntryType(file.entryType);
        const requiredAnyGroups = requiredAnyGroupsForEntryType(file.entryType);

        const recommendedSummary = document.createElement("div");
        recommendedSummary.className = "recommended-summary";
        let summary = `Required and recommended fields for ${file.entryType} are marked below.`;
        if (requiredAnyGroups.length > 0) {
          const groupText = requiredAnyGroups
            .map((group) => group.map((key) => displayFieldName(key)).join(" or "))
            .join("; ");
          summary += ` One-of requirements: ${groupText}.`;
        }
        recommendedSummary.textContent = summary;
        grid.append(recommendedSummary);

        const titleWrap = document.createElement("div");
        titleWrap.className = "field-wrap";
        if (requiredSet.has("title")) {
          titleWrap.classList.add("required");
        } else if (recommendedSet.has("title")) {
          titleWrap.classList.add("recommended");
        }
        const titleLabel = createFieldLabel("Title", {
          required: requiredSet.has("title"),
          recommended: recommendedSet.has("title"),
        });
        const titleInput = document.createElement("input");
        titleInput.className = "editor-input";
        titleInput.value = file.title || "";
        titleInput.addEventListener("input", () => {
          file.title = titleInput.value;
          headerTitle.textContent = file.title || "Untitled";
          renderTable();
          scheduleSave(file);
        });
        titleWrap.append(titleLabel, titleInput);
        grid.append(titleWrap);

        const yearWrap = document.createElement("div");
        yearWrap.className = "field-wrap";
        if (requiredSet.has("year")) {
          yearWrap.classList.add("required");
        } else if (recommendedSet.has("year")) {
          yearWrap.classList.add("recommended");
        }
        const yearLabel = createFieldLabel("Year", {
          required: requiredSet.has("year"),
          recommended: recommendedSet.has("year"),
        });
        const yearInput = document.createElement("input");
        yearInput.className = "editor-input";
        yearInput.value = file.year || "";
        yearInput.addEventListener("input", () => {
          file.year = yearInput.value;
          renderTable();
          scheduleSave(file);
        });
        yearWrap.append(yearLabel, yearInput);
        grid.append(yearWrap);

        const authorsWrap = document.createElement("div");
        authorsWrap.className = "field-wrap";
        if (requiredSet.has("authors")) {
          authorsWrap.classList.add("required");
        } else if (recommendedSet.has("authors")) {
          authorsWrap.classList.add("recommended");
        }
        const authorsLabel = createFieldLabel("Authors", {
          required: requiredSet.has("authors"),
          recommended: recommendedSet.has("authors"),
        });
        authorsWrap.append(authorsLabel);

        const authorsHint = document.createElement("div");
        authorsHint.className = "field-hint";
        authorsHint.textContent = "Each author uses first and last name. Display is formatted as APA-style names.";
        authorsWrap.append(authorsHint);

        const authorsList = document.createElement("div");
        authorsList.className = "authors-list";
        authorsWrap.append(authorsList);

        const authors = coerceAuthors(file);
        for (const author of authors) {
          const row = document.createElement("div");
          row.className = "author-row";

          const firstNameInput = document.createElement("input");
          firstNameInput.className = "editor-input";
          firstNameInput.placeholder = "First name";
          firstNameInput.value = author.firstName || "";
          firstNameInput.addEventListener("input", () => {
            author.firstName = firstNameInput.value;
            apaPreview.textContent = formatAuthorsApa(authors) || "â€”";
            if (hasIncompleteAuthorRows(authors)) {
              cancelScheduledSave(file.id);
              return;
            }
            scheduleSave(file);
          });

          const lastNameInput = document.createElement("input");
          lastNameInput.className = "editor-input";
          lastNameInput.placeholder = "Last name";
          lastNameInput.value = author.lastName || "";
          lastNameInput.addEventListener("input", () => {
            author.lastName = lastNameInput.value;
            apaPreview.textContent = formatAuthorsApa(authors) || "â€”";
            if (hasIncompleteAuthorRows(authors)) {
              cancelScheduledSave(file.id);
              return;
            }
            scheduleSave(file);
          });

          const removeBtn = document.createElement("button");
          removeBtn.type = "button";
          removeBtn.textContent = "Remove";
          removeBtn.addEventListener("click", () => {
            const idx = authors.indexOf(author);
            if (idx >= 0) {
              authors.splice(idx, 1);
              renderEditor();
              renderTable();
              scheduleSave(file);
            }
          });

          row.append(firstNameInput, lastNameInput, removeBtn);
          authorsList.append(row);
        }

        const addAuthorBtn = document.createElement("button");
        addAuthorBtn.type = "button";
        addAuthorBtn.className = "author-add-btn";
        addAuthorBtn.textContent = "+ Add author";
        addAuthorBtn.addEventListener("click", () => {
          authors.push({ firstName: "", lastName: "" });
          renderEditor();
          renderTable();
        });
        authorsWrap.append(addAuthorBtn);

        const apaPreview = document.createElement("div");
        apaPreview.className = "apa-preview";
        apaPreview.textContent = formatAuthorsApa(authors) || "â€”";
        authorsWrap.append(apaPreview);

        grid.append(authorsWrap);

        for (const field of fieldConfig) {
          const wrap = document.createElement("div");
          wrap.className = "field-wrap";
          if (requiredSet.has(field.key)) {
            wrap.classList.add("required");
          } else if (recommendedSet.has(field.key)) {
            wrap.classList.add("recommended");
          }
          const label = createFieldLabel(field.label, {
            required: requiredSet.has(field.key),
            recommended: recommendedSet.has(field.key),
          });
          wrap.append(label);

          if (field.type === "textarea") {
            const textarea = document.createElement("textarea");
            textarea.className = "editor-textarea";
            textarea.value = file[field.key] || "";
            textarea.addEventListener("input", () => {
              file[field.key] = textarea.value;
              scheduleSave(file);
            });
            wrap.append(textarea);
          } else if (field.type === "select") {
            const select = document.createElement("select");
            select.className = "editor-select";
            for (const optionValue of field.options) {
              const option = document.createElement("option");
              option.value = optionValue;
              option.textContent = optionValue;
              if (optionValue === file[field.key]) {
                option.selected = true;
              }
              select.append(option);
            }
            select.addEventListener("change", () => {
              file[field.key] = select.value;
              scheduleSave(file);
              if (field.key === "entryType") {
                renderEditor();
                renderTable();
                return;
              }
            });
            wrap.append(select);
          } else {
            const input = document.createElement("input");
            input.className = "editor-input";
            input.value = file[field.key] || "";
            input.addEventListener("input", () => {
              file[field.key] = input.value;
              if (field.key === "doi" && state.doiLookup.fileId === file.id) {
                state.doiLookup.message = "";
                state.doiLookup.error = "";
              }
              if (field.key === "citationKey") {
                renderTable();
              }
              scheduleSave(file);
            });
            if (field.key === "doi") {
              const row = document.createElement("div");
              row.className = "editor-inline-row";

              const lookupBtn = document.createElement("button");
              lookupBtn.type = "button";
              lookupBtn.className = "editor-action-btn";
              lookupBtn.addEventListener("click", () => {
                lookupByDoiForFile(file);
              });

              const updateLookupButtonState = () => {
                const hasDoi = String(input.value || "").trim().length > 0;
                const busy = state.doiLookup.running && state.doiLookup.fileId === file.id;
                lookupBtn.disabled = !hasDoi || busy;
                lookupBtn.textContent = busy ? "Looking up..." : "Lookup DOI";
              };

              input.addEventListener("input", updateLookupButtonState);
              updateLookupButtonState();
              row.append(input, lookupBtn);
              wrap.append(row);

              if (state.doiLookup.fileId === file.id) {
                if (state.doiLookup.error) {
                  const errorHint = document.createElement("div");
                  errorHint.className = "field-hint error";
                  errorHint.textContent = `DOI lookup failed: ${state.doiLookup.error}`;
                  wrap.append(errorHint);
                } else if (state.doiLookup.message) {
                  const infoHint = document.createElement("div");
                  infoHint.className = "field-hint";
                  infoHint.textContent = state.doiLookup.message;
                  wrap.append(infoHint);
                }
              }
            } else {
              wrap.append(input);
            }
          }

          grid.append(wrap);
        }

        pane.append(grid);
      }

      function renderAll() {
        renderBuckets();
        renderViewToggle();
        renderLayoutMode();
        renderAutofillControls();
        if (state.viewMode === "bulk") {
          renderBulkView();
        } else {
          renderTable();
          renderEditor();
        }
        renderModal();
      }

      initSortControls();
      initViewToggleControls();
      initAutofillControls();
      initBulkControls();
      initModalControls();
      loadBuckets();
    </script>
  </body>
</html>
