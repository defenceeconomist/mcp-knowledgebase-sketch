<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>MCP Research Tool</title>
    <link
      rel="stylesheet"
      href="https://cdn.jsdelivr.net/npm/handsontable@14.5.0/dist/handsontable.full.min.css"
    />
    <style>
      :root {
        --bg: #0b1020;
        --bg-accent: #070a14;
        --panel: #101a33;
        --panel-alt: #0f1730;
        --ink: #e7ecff;
        --muted: #aab3d6;
        --line: rgba(255, 255, 255, 0.12);
        --brand: #7aa2ff;
        --brand-soft: rgba(122, 162, 255, 0.16);
        --ok: #06d6a0;
        --warn: #ffd166;
        --bad: #ff6b6b;
        --radius: 14px;
      }

      * {
        box-sizing: border-box;
      }

      body {
        margin: 0;
        min-height: 100vh;
        font-family: "Space Grotesk", "Avenir Next", "Trebuchet MS", sans-serif;
        color: var(--ink);
        background: linear-gradient(180deg, var(--bg), var(--bg-accent));
      }

      .top-nav {
        position: sticky;
        top: 0;
        z-index: 30;
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 14px;
        padding: 10px 14px;
        background: color-mix(in oklab, var(--panel) 84%, #08101f 16%);
        border-bottom: 1px solid var(--line);
        backdrop-filter: blur(8px);
      }

      .top-nav-left {
        display: flex;
        align-items: center;
        gap: 12px;
        min-width: 0;
      }

      .top-nav-title {
        font-family: "Fraunces", "Iowan Old Style", "Times New Roman", serif;
        font-size: 18px;
        font-weight: 700;
        letter-spacing: 0.2px;
      }

      .top-nav-workspaces {
        display: flex;
        align-items: center;
        gap: 8px;
        flex-wrap: wrap;
      }

      .top-nav-summary {
        border: 1px solid var(--line);
        background: color-mix(in oklab, var(--panel-alt) 88%, #081022 12%);
        color: var(--ink);
        text-decoration: none;
        border-radius: 10px;
        padding: 7px 10px;
        font-size: 12px;
        font-weight: 600;
        cursor: pointer;
        display: inline-flex;
        align-items: center;
        gap: 6px;
      }

      .top-nav-summary:hover {
        border-color: color-mix(in oklab, var(--brand) 50%, var(--line));
      }

      .top-nav-right {
        display: flex;
        align-items: center;
        gap: 8px;
        margin-left: auto;
      }

      .top-nav-dropdown {
        position: relative;
      }

      .top-nav-dropdown > summary {
        list-style: none;
      }

      .top-nav-dropdown > summary::-webkit-details-marker {
        display: none;
      }

      .top-nav-menu {
        position: absolute;
        right: 0;
        top: calc(100% + 6px);
        min-width: 230px;
        border: 1px solid var(--line);
        border-radius: 12px;
        background: color-mix(in oklab, var(--panel) 92%, #091126 8%);
        box-shadow: 0 12px 26px rgba(0, 0, 0, 0.35);
        padding: 6px;
        display: grid;
        gap: 4px;
      }

      .top-nav-menu a {
        color: var(--ink);
        text-decoration: none;
        border-radius: 8px;
        padding: 8px 9px;
        font-size: 12px;
      }

      .top-nav-menu a:hover {
        background: color-mix(in oklab, var(--brand-soft) 76%, #0e1831 24%);
      }

      .app-shell {
        display: grid;
        grid-template-columns: 260px 1fr 360px;
        gap: 14px;
        padding: 14px;
        height: calc(100vh - 62px);
      }

      .app-shell.bulk-mode {
        grid-template-columns: 260px 1fr;
      }

      .app-shell.bulk-mode .right-pane {
        display: none;
      }

      .app-shell.browser-mode {
        grid-template-columns: 260px 1fr;
      }

      .app-shell.browser-mode .right-pane {
        display: none;
      }

      .app-shell.search-mode {
        grid-template-columns: 260px 1fr;
      }

      .app-shell.search-mode .right-pane {
        display: none;
      }

      .app-shell.browser-mode .bulk-view,
      .app-shell.browser-mode .detail-view,
      .app-shell.browser-mode .search-view {
        display: none !important;
      }

      .app-shell.search-mode .browser-view,
      .app-shell.search-mode .bulk-view,
      .app-shell.search-mode .detail-view {
        display: none !important;
      }

      .app-shell.bibtex-mode .browser-view,
      .app-shell.bibtex-mode .search-view {
        display: none !important;
      }

      .pane {
        background: color-mix(in oklab, var(--panel) 92%, #091027 8%);
        border: 1px solid var(--line);
        border-radius: var(--radius);
        overflow: hidden;
        min-height: 0;
        box-shadow: 0 10px 30px rgba(0, 0, 0, 0.25);
      }

      .pane-header {
        padding: 14px 16px 10px;
        border-bottom: 1px solid var(--line);
        background: linear-gradient(180deg, color-mix(in oklab, var(--panel-alt) 94%, #121e3e 6%), var(--panel));
      }

      .pane-title {
        margin: 0;
        font-family: "Fraunces", "Iowan Old Style", "Times New Roman", serif;
        font-size: 19px;
        line-height: 1.1;
        letter-spacing: 0.2px;
      }

      .pane-subtitle {
        margin-top: 5px;
        font-size: 12px;
        color: var(--muted);
      }

      .left-pane-content {
        padding: 10px;
        display: flex;
        flex-direction: column;
        gap: 8px;
      }

      .pane-header-row {
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 10px;
      }

      .bucket-header-actions {
        display: inline-flex;
        align-items: center;
        gap: 7px;
      }

      .bucket-icon-btn {
        width: 30px;
        height: 30px;
        border: 1px solid var(--line);
        border-radius: 9px;
        background: var(--panel-alt);
        color: var(--ink);
        font: inherit;
        font-size: 16px;
        line-height: 1;
        font-weight: 700;
        display: inline-flex;
        align-items: center;
        justify-content: center;
        cursor: pointer;
        padding: 0;
      }

      .bucket-icon-btn:hover {
        border-color: color-mix(in oklab, var(--brand) 45%, var(--line));
      }

      .bucket-icon-btn:disabled {
        opacity: 0.55;
        cursor: not-allowed;
      }

      .bucket-icon-btn.danger {
        color: color-mix(in oklab, var(--bad) 82%, var(--ink));
        background: color-mix(in oklab, var(--bad) 22%, var(--panel-alt));
        border-color: color-mix(in oklab, var(--bad) 45%, var(--line));
      }

      .bucket-manager-status {
        margin: 2px 10px 8px;
        font-size: 11px;
        color: var(--muted);
      }

      .bucket-btn {
        border: 1px solid var(--line);
        background: var(--panel-alt);
        color: var(--ink);
        border-radius: 11px;
        cursor: pointer;
        padding: 10px 12px;
        text-align: left;
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 8px;
        transition: 140ms ease;
      }

      .bucket-btn:hover {
        border-color: color-mix(in oklab, var(--brand) 35%, var(--line));
        transform: translateX(2px);
      }

      .bucket-btn.active {
        border-color: var(--brand);
        background: var(--brand-soft);
      }

      .bucket-name {
        font-size: 13px;
        font-weight: 600;
        word-break: break-word;
      }

      .bucket-count {
        font-size: 11px;
        color: var(--muted);
        border: 1px solid var(--line);
        border-radius: 999px;
        padding: 2px 7px;
        background: var(--panel);
      }

      .main-pane-body {
        display: flex;
        flex-direction: column;
        height: calc(100% - 70px);
      }

      .browser-header-tools {
        margin-top: 8px;
        display: flex;
        flex-direction: column;
        gap: 6px;
      }

      .browser-header-tools[hidden] {
        display: none !important;
      }

      .workspace-tab-btn {
        border: 1px solid var(--line);
        border-radius: 10px;
        background: color-mix(in oklab, var(--panel-alt) 88%, #081022 12%);
        color: var(--muted);
        font: inherit;
        font-size: 12px;
        font-weight: 600;
        padding: 7px 10px;
        cursor: pointer;
        display: inline-flex;
        align-items: center;
        gap: 6px;
      }

      .workspace-tab-btn.active {
        border-color: color-mix(in oklab, var(--brand) 50%, var(--line));
        background: color-mix(in oklab, var(--brand-soft) 74%, #0e1831 26%);
        color: var(--ink);
      }

      .metadata-header-tools[hidden] {
        display: none !important;
      }

      .metadata-header-tools {
        margin-top: 8px;
        display: flex;
        align-items: center;
        flex-wrap: wrap;
        gap: 8px 10px;
      }

      .table-wrap {
        padding: 10px;
        overflow: auto;
      }

      table {
        width: 100%;
        border-collapse: collapse;
        min-width: 690px;
      }

      th,
      td {
        border-bottom: 1px solid var(--line);
        padding: 9px 8px;
        font-size: 13px;
        vertical-align: top;
      }

      th {
        text-align: left;
        color: var(--muted);
        font-size: 11px;
        text-transform: uppercase;
        letter-spacing: 0.06em;
        position: sticky;
        top: 0;
        background: color-mix(in oklab, var(--panel) 94%, white 6%);
      }

      .sort-btn {
        border: none;
        background: transparent;
        color: inherit;
        font: inherit;
        text-transform: inherit;
        letter-spacing: inherit;
        cursor: pointer;
        padding: 0;
        display: inline-flex;
        align-items: center;
        gap: 6px;
      }

      .sort-btn.active {
        color: color-mix(in oklab, var(--brand) 72%, var(--muted));
      }

      .sort-indicator {
        font-size: 10px;
        line-height: 1;
      }

      .file-link {
        color: color-mix(in oklab, var(--brand) 70%, #1f5a4d);
        text-decoration: none;
        font-size: 12px;
        font-weight: 600;
        display: inline-flex;
        align-items: center;
        justify-content: center;
        line-height: 1;
        padding: 4px;
        border-radius: 8px;
      }

      .file-link:hover {
        background: color-mix(in oklab, var(--panel-alt) 80%, white 20%);
      }

      .file-link:focus-visible {
        outline: 2px solid color-mix(in oklab, var(--brand) 70%, white 30%);
        outline-offset: 2px;
      }

      .file-link svg {
        width: 16px;
        height: 16px;
        fill: currentColor;
      }

      .file-action-chip {
        display: inline-flex;
        align-items: center;
        justify-content: center;
        min-width: 28px;
        height: 20px;
        border-radius: 6px;
        border: 1px solid var(--line);
        font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;
        font-size: 10px;
        font-weight: 800;
        letter-spacing: 0.04em;
        line-height: 1;
        padding: 0 6px;
      }

      .file-action-chip-pdf {
        background: color-mix(in oklab, var(--brand-soft) 78%, var(--panel));
        color: color-mix(in oklab, var(--brand) 80%, var(--ink));
        border-color: color-mix(in oklab, var(--brand) 42%, var(--line));
      }

      .file-action-chip-md {
        background: color-mix(in oklab, #d9efe5 74%, white 26%);
        color: color-mix(in oklab, #1f7c60 80%, var(--ink));
        border-color: color-mix(in oklab, #2e7a57 42%, var(--line));
      }

      .file-action-chip-del {
        background: color-mix(in oklab, var(--bad) 24%, var(--panel));
        color: color-mix(in oklab, var(--bad) 84%, var(--ink));
        border-color: color-mix(in oklab, var(--bad) 48%, var(--line));
      }

      .file-actions {
        display: inline-flex;
        align-items: center;
        justify-content: center;
        gap: 6px;
      }

      .icon-btn {
        border: none;
        background: transparent;
        cursor: pointer;
      }

      .icon-btn:disabled {
        opacity: 0.45;
        cursor: not-allowed;
      }

      .pdf-cell {
        text-align: center;
      }

      .sr-only {
        position: absolute;
        width: 1px;
        height: 1px;
        padding: 0;
        margin: -1px;
        overflow: hidden;
        clip: rect(0, 0, 0, 0);
        white-space: nowrap;
        border: 0;
      }

      .redis-stats {
        border: 1px solid var(--line);
        border-radius: 10px;
        padding: 9px;
        background: color-mix(in oklab, var(--panel-alt) 76%, white 24%);
      }

      .redis-stats-title {
        font-size: 11px;
        letter-spacing: 0.06em;
        text-transform: uppercase;
        color: var(--muted);
      }

      .redis-stats-grid {
        margin-top: 7px;
        display: grid;
        grid-template-columns: 1fr;
        gap: 8px;
      }

      .redis-stat-btn {
        border: 1px solid var(--line);
        border-radius: 9px;
        padding: 8px 9px;
        text-align: left;
        background: var(--panel);
        color: var(--ink);
        font: inherit;
        cursor: pointer;
      }

      .redis-stat-btn:hover {
        border-color: color-mix(in oklab, var(--brand) 40%, var(--line));
      }

      .redis-stat-btn[disabled] {
        opacity: 0.58;
        cursor: not-allowed;
      }

      .redis-stat-count {
        font-size: 16px;
        font-weight: 700;
        line-height: 1.1;
      }

      .redis-stat-label {
        margin-top: 2px;
        font-size: 11px;
        color: var(--muted);
      }

      .redis-stats-meta {
        margin-top: 7px;
        font-size: 11px;
        color: var(--muted);
      }

      tbody tr {
        cursor: pointer;
      }

      tbody tr.active {
        background: color-mix(in oklab, var(--brand-soft) 62%, white 38%);
      }

      .file-name {
        font-weight: 600;
        font-size: 12px;
      }

      .table-input {
        width: 100%;
        border: 1px solid var(--line);
        border-radius: 8px;
        padding: 7px 8px;
        font: inherit;
        background: var(--panel);
        color: var(--ink);
      }

      .table-input:focus,
      .editor-input:focus,
      .editor-textarea:focus,
      .editor-select:focus {
        border-color: color-mix(in oklab, var(--brand) 55%, var(--line));
        box-shadow: 0 0 0 3px rgba(168, 67, 43, 0.13);
        outline: none;
      }

      .main-footer {
        margin-top: auto;
        border-top: 1px solid var(--line);
        padding: 10px 12px;
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 12px;
        color: var(--muted);
        font-size: 12px;
      }

      .main-tools {
        margin-top: 0;
        display: inline-flex;
        gap: 10px;
        align-items: center;
      }

      .upload-tools {
        margin-top: 8px;
        display: grid;
        grid-template-columns: auto 1fr;
        gap: 8px;
        align-items: center;
      }

      .upload-file-input {
        width: 100%;
        border: 1px solid var(--line);
        border-radius: 8px;
        background: var(--panel);
        color: var(--ink);
        font: inherit;
        font-size: 12px;
        padding: 6px 8px;
      }

      .view-toggle {
        margin-top: 0;
        display: inline-flex;
        border: 1px solid var(--line);
        border-radius: 10px;
        overflow: hidden;
        width: fit-content;
        background: color-mix(in oklab, var(--panel-alt) 78%, white 22%);
      }

      .view-toggle-btn {
        border: none;
        border-right: 1px solid var(--line);
        background: transparent;
        color: var(--muted);
        font: inherit;
        font-size: 12px;
        font-weight: 600;
        padding: 6px 10px;
        cursor: pointer;
      }

      .view-toggle-btn:last-child {
        border-right: none;
      }

      .view-toggle-btn.active {
        background: color-mix(in oklab, var(--brand-soft) 78%, white 22%);
        color: color-mix(in oklab, var(--brand) 75%, var(--ink));
      }

      .main-action-btn {
        border: 1px solid color-mix(in oklab, var(--brand) 35%, var(--line));
        background: color-mix(in oklab, var(--brand-soft) 72%, white 28%);
        color: color-mix(in oklab, var(--brand) 78%, var(--ink));
        border-radius: 9px;
        padding: 7px 10px;
        font: inherit;
        font-size: 12px;
        font-weight: 600;
        cursor: pointer;
      }

      .main-action-btn:hover {
        border-color: color-mix(in oklab, var(--brand) 65%, var(--line));
      }

      .main-action-btn:disabled {
        opacity: 0.55;
        cursor: not-allowed;
      }

      .upload-icon-btn {
        min-width: 30px;
        width: 30px;
        height: 28px;
        padding: 0;
        border-radius: 8px;
        font-size: 14px;
        line-height: 1;
      }

      .autofill-status {
        font-size: 12px;
        color: var(--muted);
      }

      .autofill-progress {
        margin-top: 8px;
      }

      .metadata-header-tools > .autofill-progress {
        flex: 1 0 100%;
        margin-top: 0;
      }

      .autofill-progress[hidden] {
        display: none !important;
      }

      .autofill-progress-track {
        height: 10px;
        border-radius: 999px;
        border: 1px solid var(--line);
        background: color-mix(in oklab, var(--panel-alt) 84%, white 16%);
        overflow: hidden;
      }

      .autofill-progress-fill {
        height: 100%;
        width: 0%;
        background: linear-gradient(90deg, var(--brand), var(--ok));
        transition: width 140ms ease;
      }

      .autofill-progress-text {
        margin-top: 5px;
        font-size: 11px;
        color: var(--muted);
      }

      .bulk-view[hidden],
      .detail-view[hidden],
      .browser-view[hidden],
      .search-view[hidden] {
        display: none !important;
      }

      .bulk-view,
      .detail-view,
      .browser-view {
        display: flex;
        flex-direction: column;
        height: 100%;
        min-height: 0;
      }

      .bulk-view .table-wrap,
      .detail-view .table-wrap {
        flex: 1;
        min-height: 0;
      }

      .search-view {
        display: flex;
        flex-direction: column;
        height: 100%;
        min-height: 0;
      }

      .browser-view {
        padding: 10px;
        gap: 10px;
        overflow: auto;
      }

      .browser-panel {
        border: 1px solid var(--line);
        border-radius: 12px;
        background: color-mix(in oklab, var(--panel) 88%, #0a142a 12%);
        padding: 10px;
      }

      .browser-toolbar-heading {
        display: inline-flex;
        align-items: center;
        gap: 10px;
        margin-right: auto;
        min-width: 240px;
      }

      .browser-toolbar-title {
        margin: 0;
        font-size: 16px;
      }

      .browser-header-subtitle {
        font-size: 12px;
        color: var(--muted);
        margin: 0 0 0 6px;
        white-space: nowrap;
      }

      .browser-status {
        display: inline-flex;
        align-items: center;
        gap: 7px;
        font-size: 12px;
        color: var(--muted);
      }

      .browser-dot {
        width: 8px;
        height: 8px;
        border-radius: 999px;
        background: var(--muted);
        display: inline-block;
      }

      .browser-dot.good {
        background: var(--ok);
      }

      .browser-dot.warn {
        background: var(--warn);
      }

      .browser-topbar {
        display: flex;
        flex-wrap: wrap;
        align-items: center;
        gap: 8px;
      }

      .browser-search-input {
        flex: 1 1 260px;
        min-width: 220px;
      }

      .browser-limit-input {
        width: 120px;
      }

      .browser-upload-btn {
        white-space: nowrap;
      }

      .browser-input {
        border: 1px solid var(--line);
        background: color-mix(in oklab, var(--panel-alt) 84%, #050910 16%);
        color: var(--ink);
        padding: 8px 10px;
        border-radius: 10px;
        font-size: 13px;
        outline: none;
        width: 100%;
      }

      .browser-input:focus {
        border-color: color-mix(in oklab, var(--brand) 55%, var(--line));
        box-shadow: 0 0 0 3px rgba(122, 162, 255, 0.2);
      }

      .browser-table {
        width: 100%;
        border-collapse: separate;
        border-spacing: 0;
        overflow: hidden;
      }

      .browser-table th,
      .browser-table td {
        text-align: left;
        padding: 10px;
        font-size: 12.5px;
        border-bottom: 1px solid var(--line);
        vertical-align: top;
      }

      .browser-table th {
        position: sticky;
        top: 0;
        background: color-mix(in oklab, var(--panel-alt) 92%, #0c1630 8%);
        z-index: 2;
        color: var(--muted);
      }

      .browser-summary-row {
        cursor: pointer;
      }

      .browser-summary-row:hover td {
        background: rgba(255, 255, 255, 0.04);
      }

      .browser-summary-row.open td {
        background: rgba(122, 162, 255, 0.1);
      }

      .browser-details-row {
        display: none;
      }

      .browser-details-row.open {
        display: table-row;
      }

      .browser-details-cell {
        padding: 10px;
        background: color-mix(in oklab, var(--panel-alt) 82%, #04080f 18%);
      }

      .browser-expander {
        border: 1px solid var(--line);
        background: rgba(255, 255, 255, 0.05);
        color: var(--ink);
        width: 22px;
        height: 22px;
        border-radius: 6px;
        cursor: pointer;
        margin-right: 8px;
        padding: 0;
        line-height: 1;
      }

      .browser-right {
        text-align: right;
      }

      .browser-nowrap {
        white-space: nowrap;
      }

      .browser-meta-card {
        display: grid;
        grid-template-columns: 1fr;
        gap: 10px;
      }

      .browser-meta-section {
        border: 1px solid var(--line);
        border-radius: 12px;
        background: color-mix(in oklab, var(--panel) 90%, #0a1227 10%);
        overflow: hidden;
      }

      .browser-meta-section > summary {
        cursor: pointer;
        padding: 10px 12px;
        font-size: 12px;
        color: var(--muted);
        letter-spacing: 0.03em;
        text-transform: uppercase;
        list-style: none;
      }

      .browser-meta-section > summary::-webkit-details-marker {
        display: none;
      }

      .browser-meta-body {
        padding: 0 12px 12px;
      }

      .browser-json {
        margin: 0;
        white-space: pre-wrap;
        word-break: break-word;
        font-size: 12px;
      }

      .browser-partition-group {
        border: 1px solid var(--line);
        border-radius: 10px;
        background: color-mix(in oklab, var(--panel-alt) 80%, #050a14 20%);
        margin-top: 10px;
        overflow: hidden;
      }

      .browser-partition-group > summary {
        cursor: pointer;
        padding: 10px;
        font-size: 12px;
        color: var(--muted);
        list-style: none;
      }

      .browser-partition-group > summary::-webkit-details-marker {
        display: none;
      }

      .browser-partition-body {
        padding: 0 10px 10px;
      }

      .browser-chunk {
        border-top: 1px solid var(--line);
        padding-top: 8px;
        margin-top: 8px;
      }

      .browser-chunk:first-child {
        border-top: none;
        padding-top: 0;
        margin-top: 0;
      }

      .browser-chunk-meta {
        font-size: 12px;
        color: var(--muted);
        margin-bottom: 6px;
      }

      .browser-chunk-text {
        margin: 0;
        white-space: pre-wrap;
        word-break: break-word;
        border: 1px solid var(--line);
        border-radius: 8px;
        padding: 8px;
        font-size: 12px;
        max-height: 220px;
        overflow: auto;
        background: color-mix(in oklab, var(--panel-alt) 78%, #04070f 22%);
      }

      .browser-footer {
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 10px;
        margin-top: 10px;
        color: var(--muted);
        font-size: 12px;
      }

      .search-controls {
        padding: 10px 12px;
        border-bottom: 1px solid var(--line);
        display: grid;
        gap: 8px;
      }

      .search-form {
        display: grid;
        grid-template-columns: minmax(0, 1.2fr) 110px 130px 180px 92px;
        gap: 8px;
        align-items: end;
      }

      .search-field {
        display: grid;
        gap: 5px;
      }

      .search-field-label {
        font-size: 11px;
        color: var(--muted);
        letter-spacing: 0.04em;
        text-transform: uppercase;
      }

      .search-input,
      .search-select {
        width: 100%;
        border: 1px solid var(--line);
        border-radius: 9px;
        padding: 7px 8px;
        font: inherit;
        font-size: 12px;
        background: var(--panel);
        color: var(--ink);
      }

      .search-input:focus,
      .search-select:focus {
        border-color: color-mix(in oklab, var(--brand) 55%, var(--line));
        box-shadow: 0 0 0 3px rgba(168, 67, 43, 0.13);
        outline: none;
      }

      .search-secondary-row {
        display: grid;
        grid-template-columns: auto 1fr;
        gap: 8px;
        align-items: end;
      }

      .search-status-line {
        font-size: 12px;
        color: var(--muted);
        justify-self: end;
        text-align: right;
        overflow-wrap: anywhere;
        word-break: break-word;
      }

      .search-results-wrap {
        flex: 1;
        min-height: 0;
        overflow: auto;
        padding: 10px 12px;
      }

      .search-meta {
        font-size: 12px;
        color: var(--muted);
      }

      .search-error {
        margin-top: 6px;
        font-size: 12px;
        color: color-mix(in oklab, var(--bad) 82%, var(--ink));
      }

      .search-results {
        margin-top: 10px;
        display: grid;
        gap: 9px;
      }

      .search-result-card {
        border: 1px solid var(--line);
        border-radius: 12px;
        background: color-mix(in oklab, var(--panel) 88%, white 12%);
        padding: 10px 11px;
      }

      .search-result-head {
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 8px;
        flex-wrap: wrap;
      }

      .search-result-id {
        min-width: 0;
        overflow-wrap: anywhere;
        word-break: break-word;
      }

      .search-score {
        border: 1px solid color-mix(in oklab, var(--brand) 35%, var(--line));
        border-radius: 999px;
        background: color-mix(in oklab, var(--brand-soft) 78%, white 22%);
        color: color-mix(in oklab, var(--brand) 75%, var(--ink));
        padding: 2px 7px;
        font-size: 11px;
      }

      .search-result-path {
        margin-top: 5px;
        font-size: 11px;
        color: var(--muted);
        font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;
      }

      .search-result-snippet {
        margin: 8px 0 0;
        font-size: 12px;
        line-height: 1.5;
        white-space: pre-wrap;
      }

      .search-actions {
        margin-top: 8px;
        display: flex;
        flex-wrap: wrap;
        gap: 6px;
      }

      .search-fetch-box {
        margin-top: 8px;
        border: 1px solid var(--line);
        border-radius: 9px;
        background: color-mix(in oklab, var(--panel-alt) 78%, white 22%);
        padding: 8px 9px;
      }

      .search-fetch-label {
        font-size: 11px;
        color: var(--muted);
        text-transform: uppercase;
        letter-spacing: 0.05em;
      }

      .search-fetch-title {
        margin-top: 4px;
        font-size: 12px;
        font-weight: 700;
      }

      .search-fetch-text {
        margin: 6px 0 0;
        font-size: 12px;
        line-height: 1.5;
        white-space: pre-wrap;
      }

      .bulk-toolbar {
        padding: 10px 12px 0;
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 10px;
      }

      .bulk-toolbar-note {
        font-size: 12px;
        color: var(--muted);
      }

      .bulk-toolbar-actions {
        display: inline-flex;
        align-items: center;
        gap: 8px;
      }

      .bulk-btn {
        border: 1px solid var(--line);
        border-radius: 8px;
        background: var(--panel-alt);
        color: var(--ink);
        font: inherit;
        font-size: 12px;
        font-weight: 600;
        cursor: pointer;
        padding: 6px 10px;
      }

      .bulk-btn:hover {
        border-color: color-mix(in oklab, var(--brand) 45%, var(--line));
      }

      .bulk-btn:disabled {
        opacity: 0.55;
        cursor: not-allowed;
      }

      .bulk-cell-input {
        width: 100%;
        border: 1px solid var(--line);
        border-radius: 6px;
        background: var(--panel);
        color: var(--ink);
        font: inherit;
        font-size: 12px;
        padding: 6px 7px;
      }

      .bulk-cell-input.readonly {
        background: color-mix(in oklab, var(--panel-alt) 84%, white 16%);
        color: var(--muted);
        border-style: dashed;
      }

      .bulk-grid-wrap {
        min-height: 380px;
      }

      .bulk-hot {
        width: 100%;
      }

      .bulk-hot-message {
        border: 1px dashed var(--line);
        border-radius: 10px;
        padding: 18px;
        color: var(--muted);
        font-size: 13px;
        background: color-mix(in oklab, var(--panel-alt) 78%, white 22%);
      }

      .bulk-hot-message[hidden] {
        display: none !important;
      }

      .hot .htDimmed {
        color: var(--muted);
      }

      .dot {
        width: 8px;
        height: 8px;
        border-radius: 999px;
        background: var(--ok);
        display: inline-block;
        margin-right: 6px;
      }

      .right-pane-content {
        padding: 12px;
        height: calc(100% - 70px);
        overflow: auto;
      }

      .editor-empty {
        border: 1px dashed var(--line);
        border-radius: 12px;
        padding: 22px;
        text-align: center;
        color: var(--muted);
        font-size: 13px;
        margin-top: 10px;
      }

      .editor-head {
        border: 1px solid var(--line);
        background: var(--panel-alt);
        border-radius: 12px;
        padding: 10px 11px;
        margin-bottom: 11px;
      }

      .editor-head-top {
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 10px;
      }

      .editor-file {
        font-size: 12px;
        color: var(--muted);
        margin-bottom: 4px;
      }

      .editor-title {
        font-size: 14px;
        font-weight: 700;
      }

      .editor-clear-btn {
        border: 1px solid color-mix(in oklab, var(--bad) 45%, var(--line));
        border-radius: 8px;
        background: color-mix(in oklab, var(--bad) 22%, var(--panel-alt));
        color: color-mix(in oklab, var(--bad) 84%, var(--ink));
        font: inherit;
        font-size: 12px;
        font-weight: 600;
        cursor: pointer;
        padding: 6px 9px;
      }

      .editor-clear-btn:hover {
        border-color: color-mix(in oklab, var(--bad) 70%, var(--line));
      }

      .field-grid {
        display: grid;
        grid-template-columns: 1fr;
        gap: 10px;
      }

      .field-label {
        display: block;
        font-size: 13px;
        letter-spacing: 0.06em;
        text-transform: uppercase;
        color: var(--muted);
        margin-bottom: 5px;
      }

      .editor-input,
      .editor-select,
      .editor-textarea {
        width: 100%;
        border: 1px solid var(--line);
        border-radius: 9px;
        padding: 8px 9px;
        font: inherit;
        font-size: 13px;
        background: var(--panel);
        color: var(--ink);
      }

      .editor-textarea {
        min-height: 78px;
        resize: vertical;
      }

      .field-hint {
        margin-top: 4px;
        font-size: 13px;
        color: var(--muted);
      }

      .field-hint.error {
        color: color-mix(in oklab, var(--bad) 82%, var(--ink));
      }

      .editor-inline-row {
        display: grid;
        grid-template-columns: 1fr auto;
        gap: 8px;
        align-items: center;
      }

      .editor-action-btn {
        border: 1px solid var(--line);
        border-radius: 8px;
        background: var(--panel-alt);
        color: var(--ink);
        font: inherit;
        font-size: 12px;
        font-weight: 600;
        cursor: pointer;
        padding: 7px 10px;
        white-space: nowrap;
      }

      .editor-action-btn:hover {
        border-color: color-mix(in oklab, var(--brand) 45%, var(--line));
      }

      .editor-action-btn:disabled {
        opacity: 0.55;
        cursor: not-allowed;
      }

      .recommended-summary {
        border: 1px solid var(--line);
        border-radius: 10px;
        padding: 8px 9px;
        font-size: 13px;
        color: color-mix(in oklab, var(--ink) 88%, var(--muted));
        background: color-mix(in oklab, var(--panel-alt) 78%, white 22%);
      }

      .field-wrap {
        border: 1px solid transparent;
        border-radius: 10px;
        padding: 7px;
      }

      .field-wrap.recommended {
        border-color: color-mix(in oklab, var(--brand) 62%, var(--line));
        background: color-mix(in oklab, var(--brand-soft) 70%, var(--panel));
      }

      .field-wrap.recommended .field-label {
        color: color-mix(in oklab, var(--ink) 84%, var(--brand));
      }

      .field-wrap.required {
        border-color: color-mix(in oklab, var(--bad) 50%, var(--line));
        background: color-mix(in oklab, var(--bad) 15%, var(--panel-alt));
      }

      .required-badge {
        display: inline-flex;
        align-items: center;
        border: 1px solid color-mix(in oklab, var(--bad) 50%, var(--line));
        border-radius: 999px;
        padding: 2px 7px;
        margin-left: 6px;
        font-size: 10px;
        letter-spacing: 0.04em;
        text-transform: uppercase;
        color: color-mix(in oklab, var(--bad) 84%, var(--ink));
        background: color-mix(in oklab, var(--bad) 22%, var(--panel));
      }

      .recommended-badge {
        display: inline-flex;
        align-items: center;
        border: 1px solid color-mix(in oklab, var(--brand) 65%, var(--line));
        border-radius: 999px;
        padding: 2px 7px;
        margin-left: 6px;
        font-size: 10px;
        font-weight: 700;
        letter-spacing: 0.04em;
        text-transform: uppercase;
        color: var(--ink);
        background: color-mix(in oklab, var(--brand) 42%, var(--panel-alt));
      }

      .authors-list {
        display: flex;
        flex-direction: column;
        gap: 8px;
      }

      .author-row {
        display: grid;
        grid-template-columns: 1fr 1fr auto;
        gap: 8px;
      }

      .author-row button {
        border: 1px solid var(--line);
        border-radius: 8px;
        background: var(--panel-alt);
        color: var(--ink);
        font: inherit;
        cursor: pointer;
        padding: 0 9px;
      }

      .author-row button:hover,
      .author-add-btn:hover {
        border-color: color-mix(in oklab, var(--brand) 40%, var(--line));
      }

      .author-add-btn {
        margin-top: 8px;
        border: 1px solid var(--line);
        border-radius: 9px;
        background: var(--panel-alt);
        color: var(--ink);
        font: inherit;
        font-size: 12px;
        cursor: pointer;
        padding: 7px 10px;
      }

      .apa-preview {
        margin-top: 8px;
        border: 1px dashed var(--line);
        border-radius: 9px;
        padding: 8px 9px;
        font-size: 12px;
        color: var(--muted);
        background: color-mix(in oklab, var(--panel-alt) 75%, white 25%);
      }

      .modal-backdrop {
        position: fixed;
        inset: 0;
        background: rgba(24, 20, 14, 0.46);
        display: flex;
        align-items: center;
        justify-content: center;
        padding: 18px;
        z-index: 50;
      }

      .modal-backdrop[hidden] {
        display: none !important;
      }

      .modal-card {
        width: min(920px, 100%);
        max-height: calc(100vh - 36px);
        overflow: hidden;
        border: 1px solid var(--line);
        border-radius: 14px;
        background: var(--panel);
        box-shadow: 0 18px 40px rgba(44, 42, 36, 0.20);
        display: flex;
        flex-direction: column;
      }

      .modal-head {
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 10px;
        padding: 11px 12px;
        border-bottom: 1px solid var(--line);
      }

      .modal-title {
        margin: 0;
        font-family: "Fraunces", "Iowan Old Style", "Times New Roman", serif;
        font-size: 18px;
      }

      .modal-close {
        border: 1px solid var(--line);
        border-radius: 8px;
        background: var(--panel-alt);
        color: var(--ink);
        font: inherit;
        cursor: pointer;
        padding: 5px 8px;
      }

      .modal-body {
        padding: 10px 12px 14px;
        overflow: auto;
      }

      .modal-card.compact {
        width: min(460px, 100%);
      }

      .modal-field {
        display: grid;
        gap: 6px;
      }

      .modal-label {
        font-size: 12px;
        color: var(--muted);
      }

      .modal-input {
        width: 100%;
        border: 1px solid var(--line);
        border-radius: 9px;
        padding: 8px 9px;
        font: inherit;
        background: var(--panel);
        color: var(--ink);
      }

      .modal-input:focus {
        border-color: color-mix(in oklab, var(--brand) 55%, var(--line));
        box-shadow: 0 0 0 3px rgba(168, 67, 43, 0.13);
        outline: none;
      }

      .modal-actions {
        margin-top: 12px;
        display: flex;
        justify-content: flex-end;
        gap: 8px;
      }

      .modal-action-btn {
        border: 1px solid var(--line);
        border-radius: 8px;
        background: var(--panel-alt);
        color: var(--ink);
        font: inherit;
        font-size: 12px;
        font-weight: 600;
        cursor: pointer;
        padding: 7px 10px;
      }

      .modal-action-btn.primary {
        border-color: color-mix(in oklab, var(--brand) 40%, var(--line));
        background: color-mix(in oklab, var(--brand-soft) 75%, white 25%);
        color: color-mix(in oklab, var(--brand) 78%, var(--ink));
      }

      .modal-action-btn.danger {
        border-color: color-mix(in oklab, var(--bad) 45%, var(--line));
        background: color-mix(in oklab, var(--bad) 22%, var(--panel-alt));
        color: color-mix(in oklab, var(--bad) 84%, var(--ink));
      }

      .modal-action-btn:disabled {
        opacity: 0.55;
        cursor: not-allowed;
      }

      .modal-note {
        color: var(--muted);
        font-size: 12px;
        margin-bottom: 8px;
      }

      .modal-item {
        border: 1px solid var(--line);
        border-radius: 10px;
        padding: 8px 9px;
        margin-bottom: 8px;
        background: color-mix(in oklab, var(--panel-alt) 73%, white 27%);
      }

      .modal-item-label {
        font-size: 11px;
        color: var(--muted);
        margin-bottom: 5px;
      }

      .modal-item-text {
        margin: 0;
        font-size: 12px;
        white-space: pre-wrap;
        word-break: break-word;
      }

      @media (max-width: 1220px) {
        .app-shell {
          grid-template-columns: 220px 1fr;
          grid-template-rows: 1fr 1fr;
        }
        .right-pane {
          grid-column: 1 / -1;
        }
      }

      @media (max-width: 860px) {
        .top-nav {
          flex-direction: column;
          align-items: stretch;
        }

        .top-nav-left {
          flex-direction: column;
          align-items: stretch;
          gap: 10px;
        }

        .top-nav-workspaces {
          display: grid;
          grid-template-columns: 1fr;
          gap: 8px;
        }

        .workspace-tab-btn {
          width: 100%;
          justify-content: center;
        }

        .top-nav-right {
          margin-left: 0;
          display: grid;
          grid-template-columns: 1fr;
          gap: 8px;
        }

        .top-nav-dropdown {
          width: 100%;
        }

        .top-nav-summary {
          width: 100%;
          justify-content: center;
        }

        .top-nav-menu {
          position: static;
          margin-top: 6px;
          width: 100%;
        }

        .app-shell {
          grid-template-columns: 1fr;
          grid-template-rows: auto auto auto;
          height: auto;
          min-height: 100vh;
        }
        .pane {
          min-height: 280px;
        }

        .search-form {
          grid-template-columns: 1fr 1fr;
        }

        .search-field.search-field-query {
          grid-column: 1 / -1;
        }

        .search-run-btn {
          grid-column: 1 / -1;
          width: 100%;
        }

        .search-secondary-row {
          grid-template-columns: 1fr;
        }

        .search-status-line {
          justify-self: start;
          text-align: left;
        }

        .browser-topbar {
          flex-direction: column;
          align-items: stretch;
        }

        .browser-toolbar-heading {
          width: 100%;
          justify-content: space-between;
          min-width: 0;
        }

        .browser-limit-input {
          width: 100%;
        }

        .browser-header-subtitle {
          margin-left: 0;
          white-space: normal;
        }
      }

      @media (max-width: 560px) {
        .search-controls {
          padding: 9px 10px;
        }

        .search-form {
          grid-template-columns: 1fr;
        }

        .search-field.search-field-query,
        .search-run-btn {
          grid-column: 1;
        }

        .search-results-wrap {
          padding: 9px 10px;
        }

        .search-result-head {
          flex-direction: column;
          align-items: flex-start;
        }

        .search-actions .bulk-btn {
          flex: 1 1 100%;
          text-align: center;
        }
      }
    </style>
  </head>
  <body>
    <header class="top-nav">
      <div class="top-nav-left">
        <div class="top-nav-title">MCP Research Tool</div>
        <div class="top-nav-workspaces" id="workspaceTabs" aria-label="Workspace Sections">
          <button type="button" class="workspace-tab-btn active" id="workspaceTabBrowser">Browser</button>
          <button type="button" class="workspace-tab-btn" id="workspaceTabBibtex">BibTeX</button>
          <button type="button" class="workspace-tab-btn" id="workspaceTabSearch">Semantic Search</button>
        </div>
      </div>
      <nav class="top-nav-right" aria-label="Primary">
        <details class="top-nav-dropdown">
          <summary class="top-nav-summary">Docs ▾</summary>
          <div class="top-nav-menu">
            <a href="/docs/?doc=README.md">README</a>
            <a href="/docs/?doc=tool-documentation.md">Tool Documentation</a>
            <a href="/docs/?doc=test-documentation.md">Test Documentation</a>
          </div>
        </details>

        <details class="top-nav-dropdown">
          <summary class="top-nav-summary">Developer Tools ▾</summary>
          <div class="top-nav-menu">
            <a href="/redisinsight/" onclick="window.open(this.href, '_blank', 'noopener,noreferrer'); return false;">RedisInsight</a>
            <a href="/minio/" onclick="window.open(this.href, '_blank', 'noopener,noreferrer'); return false;">MinIO Console</a>
            <a href="/qdrant/" onclick="window.open(this.href, '_blank', 'noopener,noreferrer'); return false;">Qdrant Dashboard</a>
            <a href="/flower/" onclick="window.open(this.href, '_blank', 'noopener,noreferrer'); return false;">Flower</a>
          </div>
        </details>
      </nav>
    </header>

    <div class="app-shell" id="appShell">
      <aside class="pane left-pane">
        <div class="pane-header">
          <div class="pane-header-row">
            <h1 class="pane-title">Buckets</h1>
            <div class="bucket-header-actions">
              <button
                type="button"
                id="openAddBucketModalBtn"
                class="bucket-icon-btn"
                title="Add bucket"
                aria-label="Add bucket"
              >
                +
              </button>
              <button
                type="button"
                id="openDeleteBucketModalBtn"
                class="bucket-icon-btn danger"
                title="Delete selected bucket"
                aria-label="Delete selected bucket"
              >
                -
              </button>
            </div>
          </div>
          <div class="pane-subtitle">Choose a collection of files</div>
        </div>
        <div class="left-pane-content" id="bucketList"></div>
        <div class="bucket-manager-status" id="bucketManagerStatus">Ready.</div>
      </aside>

      <main class="pane main-pane">
        <div class="pane-header" id="mainPaneHeader">
          <h2 class="pane-title" id="tableTitle">Files</h2>
          <div class="pane-subtitle" id="mainPaneSubtitle">Browse Qdrant files with Redis/Qdrant metadata and chunk partitions.</div>
          <div class="browser-header-tools" id="browserHeaderTools" hidden>
            <div class="browser-topbar">
              <div class="browser-toolbar-heading">
                <h3 class="browser-toolbar-title" id="browserTitle">Select a bucket</h3>
                <div class="browser-status">
                  <span class="browser-dot" id="browserRedisDot"></span>
                  <span id="browserRedisStatus">Redis: unknown</span>
                </div>
              </div>
              <input class="browser-input browser-search-input" id="browserSearch" placeholder="Search key/source/document id..." />
              <input class="browser-input browser-limit-input" id="browserLimit" type="number" min="1" max="2000" value="200" />
              <button class="bulk-btn" id="browserReload" type="button">Load</button>
              <button class="bulk-btn" id="browserLoadMore" type="button" disabled>Load more</button>
              <button
                type="button"
                id="openUploadModalBtn"
                class="main-action-btn browser-upload-btn"
                title="Upload PDF files"
                aria-label="Upload PDF files"
              >
                Upload PDF
              </button>
              <div class="browser-header-subtitle" id="browserSubtitle">Choose a shared bucket to inspect Qdrant metadata.</div>
            </div>
            <div id="uploadStatus" class="autofill-status" hidden></div>
            <div class="autofill-progress" id="uploadProgress" hidden>
              <div class="autofill-progress-track">
                <div class="autofill-progress-fill" id="uploadProgressFill"></div>
              </div>
              <div class="autofill-progress-text" id="uploadProgressText"></div>
            </div>
          </div>
          <div class="metadata-header-tools" id="metadataHeaderTools">
            <div class="view-toggle" id="viewToggle">
              <button type="button" class="view-toggle-btn" id="viewToggleBulk">Bulk Edit</button>
              <button type="button" class="view-toggle-btn" id="viewToggleDetail">Detail Edit</button>
            </div>
            <div class="main-tools">
              <button type="button" id="autofillMissingBtn" class="main-action-btn">Autofill Missing Metadata</button>
              <div id="autofillStatus" class="autofill-status">Ready.</div>
            </div>
            <div class="autofill-progress" id="autofillProgress" hidden>
              <div class="autofill-progress-track">
                <div class="autofill-progress-fill" id="autofillProgressFill"></div>
              </div>
              <div class="autofill-progress-text" id="autofillProgressText"></div>
            </div>
          </div>
        </div>
        <div class="main-pane-body">
          <div class="browser-view" id="browserView">
            <div class="browser-panel">
              <table class="browser-table">
                <thead>
                  <tr>
                    <th style="width: 62%">File</th>
                    <th class="browser-right browser-nowrap">Partitions</th>
                    <th class="browser-right browser-nowrap">Chunks</th>
                  </tr>
                </thead>
                <tbody id="browserRows">
                  <tr><td colspan="3">No data loaded.</td></tr>
                </tbody>
              </table>
              <div class="browser-footer">
                <div id="browserFooterLeft">-</div>
                <div id="browserFooterRight">-</div>
              </div>
            </div>
          </div>

          <div class="bulk-view" id="bulkView" hidden>
            <div class="bulk-toolbar">
              <div class="bulk-toolbar-note">Paste tabular cells from Excel/Sheets. First two columns (MinIO path, Redis doc id) are read-only.</div>
              <div class="bulk-toolbar-actions">
                <button type="button" class="bulk-btn" id="bulkCopyBtn">Copy TSV</button>
                <button type="button" class="bulk-btn" id="bulkSaveBtn">Save Pending Changes</button>
              </div>
            </div>
            <div class="table-wrap bulk-grid-wrap">
              <div id="bulkHotMessage" class="bulk-hot-message" hidden></div>
              <div id="bulkHot" class="bulk-hot"></div>
            </div>
            <div class="main-footer">
              <div><span class="dot"></span>Bulk edits are local until you press Save Pending Changes</div>
              <div id="bulkStatus">No pending changes.</div>
            </div>
          </div>

          <div class="detail-view" id="detailView" hidden>
            <div class="table-wrap">
              <table>
                <thead>
                  <tr>
                    <th style="width: 30%">
                      <button class="sort-btn" type="button" data-sort-key="title">
                        Title
                        <span class="sort-indicator"></span>
                      </button>
                    </th>
                    <th style="width: 12%">
                      <button class="sort-btn" type="button" data-sort-key="year">
                        Year
                        <span class="sort-indicator"></span>
                      </button>
                    </th>
                    <th style="width: 22%">
                      <button class="sort-btn" type="button" data-sort-key="authors">
                        Authors
                        <span class="sort-indicator"></span>
                      </button>
                    </th>
                    <th style="width: 28%">
                      <button class="sort-btn" type="button" data-sort-key="source">
                        Journal / Book
                        <span class="sort-indicator"></span>
                      </button>
                    </th>
                    <th style="width: 8%; text-align: center"><span class="sr-only">Links</span></th>
                  </tr>
                </thead>
                <tbody id="fileTableBody"></tbody>
              </table>
            </div>
            <div class="main-footer">
              <div><span class="dot"></span>BibTeX metadata autosaves to Redis (prefix: bibtex)</div>
              <div id="selectionHint">Select a file to edit extra BibTeX fields</div>
            </div>
          </div>

          <div class="search-view" id="searchView" hidden>
            <div class="search-controls">
              <form id="searchForm" class="search-form">
                <div class="search-field search-field-query">
                  <label class="search-field-label" for="searchQueryInput">query</label>
                  <input
                    id="searchQueryInput"
                    class="search-input"
                    placeholder="Ask a question about your indexed corpus"
                    autocomplete="off"
                  />
                </div>
                <div class="search-field">
                  <label class="search-field-label" for="searchTopKInput">top_k</label>
                  <input id="searchTopKInput" class="search-input" type="number" min="1" max="50" value="8" />
                </div>
                <div class="search-field" id="searchPrefetchField">
                  <label class="search-field-label" for="searchPrefetchKInput">prefetch_k</label>
                  <input
                    id="searchPrefetchKInput"
                    class="search-input"
                    type="number"
                    min="1"
                    max="500"
                    value="60"
                  />
                </div>
                <div class="search-field">
                  <label class="search-field-label" for="searchRetrievalModeInput">retrieval mode</label>
                  <select id="searchRetrievalModeInput" class="search-select">
                    <option value="hybrid" selected>hybrid</option>
                    <option value="cosine">cosine</option>
                  </select>
                </div>
                <button type="submit" class="main-action-btn search-run-btn" id="searchRunBtn">Search</button>
              </form>

              <div class="search-secondary-row">
                <button type="button" class="bulk-btn" id="searchRefreshBtn">Refresh</button>
                <div class="search-status-line" id="searchStatusLine">Status: waiting to initialize search tools.</div>
              </div>
            </div>
            <div class="search-results-wrap">
              <div class="search-meta" id="searchMeta">Run a search to see results.</div>
              <div class="search-error" id="searchError"></div>
              <section class="search-results" id="searchResults"></section>
              <div class="editor-empty" id="searchEmptyState">Run a search query to see ranked chunks.</div>
            </div>
          </div>
        </div>
      </main>

      <aside class="pane right-pane">
        <div class="pane-header">
          <h2 class="pane-title">BibTeX Fields</h2>
          <div class="pane-subtitle">Edit title, year, structured authors, editors, and other metadata for the selected file</div>
        </div>
        <div class="right-pane-content" id="editorPane"></div>
      </aside>
    </div>

    <div class="modal-backdrop" id="dataModal" hidden>
      <div class="modal-card" role="dialog" aria-modal="true" aria-labelledby="dataModalTitle">
        <div class="modal-head">
          <h3 class="modal-title" id="dataModalTitle">Redis Data</h3>
          <button type="button" class="modal-close" id="dataModalClose">Close</button>
        </div>
        <div class="modal-body" id="dataModalBody"></div>
      </div>
    </div>

    <div class="modal-backdrop" id="addBucketModal" hidden>
      <div class="modal-card compact" role="dialog" aria-modal="true" aria-labelledby="addBucketModalTitle">
        <div class="modal-head">
          <h3 class="modal-title" id="addBucketModalTitle">Add Bucket</h3>
          <button type="button" class="modal-close" id="addBucketModalClose">Close</button>
        </div>
        <div class="modal-body">
          <div class="modal-field">
            <label class="modal-label" for="addBucketModalInput">Bucket name</label>
            <input
              id="addBucketModalInput"
              class="modal-input"
              type="text"
              placeholder="new-bucket-name"
              autocomplete="off"
            />
          </div>
          <div class="modal-actions">
            <button type="button" class="modal-action-btn" id="addBucketModalCancel">Cancel</button>
            <button type="button" class="modal-action-btn primary" id="addBucketConfirmBtn">Create Bucket</button>
          </div>
        </div>
      </div>
    </div>

    <div class="modal-backdrop" id="deleteBucketModal" hidden>
      <div class="modal-card compact" role="dialog" aria-modal="true" aria-labelledby="deleteBucketModalTitle">
        <div class="modal-head">
          <h3 class="modal-title" id="deleteBucketModalTitle">Delete Bucket</h3>
          <button type="button" class="modal-close" id="deleteBucketModalClose">Close</button>
        </div>
        <div class="modal-body">
          <div class="modal-note" id="deleteBucketModalText">
            This removes the selected bucket and all files in it.
          </div>
          <div class="modal-note">
            Ingested Redis/Qdrant data for those files is deleted as well.
          </div>
          <div class="modal-actions">
            <button type="button" class="modal-action-btn" id="deleteBucketModalCancel">Cancel</button>
            <button type="button" class="modal-action-btn danger" id="deleteBucketConfirmBtn">Delete Bucket</button>
          </div>
        </div>
      </div>
    </div>

    <div class="modal-backdrop" id="uploadModal" hidden>
      <div class="modal-card compact" role="dialog" aria-modal="true" aria-labelledby="uploadModalTitle">
        <div class="modal-head">
          <h3 class="modal-title" id="uploadModalTitle">Upload PDF Files</h3>
          <button type="button" class="modal-close" id="uploadModalClose">Close</button>
        </div>
        <div class="modal-body">
          <div class="modal-field">
            <label class="modal-label" for="uploadModalFilesInput">Files (PDF only)</label>
            <input
              id="uploadModalFilesInput"
              class="upload-file-input"
              type="file"
              accept=".pdf,application/pdf"
              multiple
            />
          </div>
          <div class="modal-note" style="margin-top: 8px">
            Ingest runs automatically after upload. Multiple files are queued in Celery.
          </div>
          <div class="modal-actions">
            <button type="button" class="modal-action-btn" id="uploadModalCancel">Cancel</button>
            <button type="button" class="modal-action-btn primary" id="uploadModalSubmit">Upload</button>
          </div>
        </div>
      </div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/handsontable@14.5.0/dist/handsontable.full.min.js"></script>
    <script>
      const APP_BASE_PATH = (() => {
        const path = String(window.location.pathname || "").replace(/\/+$/, "");
        if (!path || path === "/") {
          return "";
        }
        const [firstSegment] = path.split("/").filter(Boolean);
        return firstSegment ? `/${firstSegment}` : "";
      })();

      function rewriteApiRequestUrl(input) {
        if (!APP_BASE_PATH) {
          return input;
        }
        try {
          if (typeof input === "string") {
            if (input.startsWith("/api/")) {
              return `${APP_BASE_PATH}${input}`;
            }
            const parsed = new URL(input, window.location.origin);
            if (parsed.origin === window.location.origin && parsed.pathname.startsWith("/api/")) {
              parsed.pathname = `${APP_BASE_PATH}${parsed.pathname}`;
              return parsed.toString();
            }
            return input;
          }
          if (input instanceof URL) {
            if (input.origin === window.location.origin && input.pathname.startsWith("/api/")) {
              const rewritten = new URL(input.toString());
              rewritten.pathname = `${APP_BASE_PATH}${input.pathname}`;
              return rewritten;
            }
            return input;
          }
        } catch (_err) {
          return input;
        }
        return input;
      }

      const rawFetch = window.fetch.bind(window);
      window.fetch = (input, init) => rawFetch(rewriteApiRequestUrl(input), init);

      const entryTypeOptions = [
        "article",
        "book",
        "booklet",
        "conference",
        "inbook",
        "incollection",
        "inproceedings",
        "manual",
        "mastersthesis",
        "misc",
        "phdthesis",
        "proceedings",
        "techreport",
        "unpublished",
      ];

      const fieldConfig = [
        { key: "citationKey", label: "Citation Key", type: "text" },
        {
          key: "entryType",
          label: "Entry Type",
          type: "select",
          options: entryTypeOptions,
        },
        { key: "address", label: "Address", type: "text" },
        { key: "annote", label: "Annote", type: "textarea" },
        { key: "booktitle", label: "Booktitle", type: "text" },
        { key: "chapter", label: "Chapter", type: "text" },
        { key: "crossref", label: "Crossref", type: "text" },
        { key: "doi", label: "DOI", type: "text" },
        { key: "edition", label: "Edition", type: "text" },
        { key: "editors", label: "Editors", type: "text" },
        { key: "howpublished", label: "How Published", type: "text" },
        { key: "institution", label: "Institution", type: "text" },
        { key: "journal", label: "Journal", type: "text" },
        { key: "key", label: "Key", type: "text" },
        { key: "month", label: "Month", type: "text" },
        { key: "note", label: "Note", type: "textarea" },
        { key: "number", label: "Number", type: "text" },
        { key: "organization", label: "Organization", type: "text" },
        { key: "pages", label: "Pages", type: "text" },
        { key: "publisher", label: "Publisher", type: "text" },
        { key: "school", label: "School", type: "text" },
        { key: "series", label: "Series", type: "text" },
        { key: "type", label: "Type", type: "text" },
        { key: "url", label: "URL", type: "text" },
        { key: "volume", label: "Volume", type: "text" },
        { key: "keywords", label: "Keywords", type: "text" },
        { key: "abstract", label: "Abstract", type: "textarea" },
      ];

      const persistFieldKeys = [
        "citationKey",
        "entryType",
        "title",
        "year",
        "authors",
        "address",
        "annote",
        "chapter",
        "crossref",
        "edition",
        "editors",
        "howpublished",
        "institution",
        "journal",
        "key",
        "month",
        "booktitle",
        "organization",
        "publisher",
        "school",
        "series",
        "type",
        "volume",
        "number",
        "pages",
        "doi",
        "url",
        "keywords",
        "abstract",
        "note",
      ];

      const entryTypeRules = {
        article: {
          requiredAll: ["authors", "title", "journal", "year"],
          requiredAny: [],
          recommended: ["volume", "number", "pages", "month", "doi", "url"],
        },
        book: {
          requiredAll: ["title", "publisher", "year"],
          requiredAny: [["authors", "editors"]],
          recommended: ["volume", "number", "series", "address", "edition", "month", "doi", "url"],
        },
        booklet: {
          requiredAll: ["title"],
          requiredAny: [],
          recommended: ["authors", "howpublished", "address", "month", "year", "doi", "url", "note"],
        },
        conference: {
          requiredAll: ["authors", "title", "booktitle", "year"],
          requiredAny: [],
          recommended: ["editors", "volume", "number", "series", "pages", "address", "month", "organization", "publisher", "doi", "url", "note"],
        },
        inbook: {
          requiredAll: ["title", "publisher", "year"],
          requiredAny: [["authors", "editors"], ["chapter", "pages"]],
          recommended: ["volume", "number", "series", "type", "address", "edition", "month", "doi", "url", "note"],
        },
        incollection: {
          requiredAll: ["authors", "title", "booktitle", "publisher", "year"],
          requiredAny: [],
          recommended: ["editors", "volume", "number", "series", "type", "chapter", "pages", "address", "edition", "month", "doi", "url", "note"],
        },
        inproceedings: {
          requiredAll: ["authors", "title", "booktitle", "year"],
          requiredAny: [],
          recommended: ["editors", "volume", "number", "series", "pages", "address", "month", "organization", "publisher", "doi", "url", "note"],
        },
        manual: {
          requiredAll: ["title"],
          requiredAny: [],
          recommended: ["authors", "organization", "address", "edition", "month", "year", "doi", "url", "note"],
        },
        mastersthesis: {
          requiredAll: ["authors", "title", "school", "year"],
          requiredAny: [],
          recommended: ["type", "address", "month", "doi", "url", "note"],
        },
        misc: {
          requiredAll: [],
          requiredAny: [],
          recommended: ["authors", "title", "howpublished", "month", "year", "doi", "url", "note"],
        },
        phdthesis: {
          requiredAll: ["authors", "title", "school", "year"],
          requiredAny: [],
          recommended: ["type", "address", "month", "doi", "url", "note"],
        },
        proceedings: {
          requiredAll: ["title", "year"],
          requiredAny: [],
          recommended: ["editors", "volume", "number", "series", "address", "month", "organization", "publisher", "doi", "url", "note"],
        },
        techreport: {
          requiredAll: ["authors", "title", "institution", "year"],
          requiredAny: [],
          recommended: ["type", "number", "address", "month", "doi", "url", "note"],
        },
        unpublished: {
          requiredAll: ["authors", "title", "note"],
          requiredAny: [],
          recommended: ["month", "year", "doi", "url"],
        },
      };

      const appRequiredFields = ["citationKey", "entryType"];

      const defaultFileFields = {
        citationKey: "",
        entryType: "article",
        title: "",
        year: "",
        authors: [],
        address: "",
        annote: "",
        chapter: "",
        crossref: "",
        edition: "",
        editors: "",
        howpublished: "",
        institution: "",
        journal: "",
        key: "",
        month: "",
        booktitle: "",
        organization: "",
        publisher: "",
        school: "",
        series: "",
        type: "",
        volume: "",
        number: "",
        pages: "",
        doi: "",
        url: "",
        keywords: "",
        abstract: "",
        note: "",
      };

      const bulkColumns = [
        { key: "minioPath", label: "MinIO Path", readOnly: true },
        { key: "redisDocId", label: "Redis Doc ID", readOnly: true },
        { key: "title", label: "Title" },
        { key: "year", label: "Year" },
        { key: "authors", label: "Authors" },
        { key: "address", label: "Address" },
        { key: "annote", label: "Annote" },
        { key: "chapter", label: "Chapter" },
        { key: "crossref", label: "Crossref" },
        { key: "edition", label: "Edition" },
        { key: "editors", label: "Editors" },
        { key: "howpublished", label: "How Published" },
        { key: "institution", label: "Institution" },
        { key: "key", label: "Key" },
        { key: "month", label: "Month" },
        { key: "doi", label: "DOI" },
        { key: "entryType", label: "Entry Type" },
        { key: "journal", label: "Journal" },
        { key: "booktitle", label: "Booktitle" },
        { key: "organization", label: "Organization" },
        { key: "publisher", label: "Publisher" },
        { key: "school", label: "School" },
        { key: "series", label: "Series" },
        { key: "type", label: "Type" },
        { key: "volume", label: "Volume" },
        { key: "number", label: "Number" },
        { key: "pages", label: "Pages" },
        { key: "url", label: "URL" },
        { key: "keywords", label: "Keywords" },
        { key: "note", label: "Note" },
        { key: "abstract", label: "Abstract" },
        { key: "citationKey", label: "Citation Key" },
      ];

      const saveTimers = new Map();
      const saveInFlightByFileId = new Map();
      const autofillBatchSize = 20;
      const ingestPollDelayMs = 900;
      const selectedBucketCookieName = "mcp_research_selected_bucket";
      const selectedBucketCookieMaxAgeSec = 60 * 60 * 24 * 365;
      const bulkWidthDefaults = { min: 120, max: 420 };
      const bulkWidthByColumn = {
        minioPath: { min: 220, max: 560 },
        redisDocId: { min: 170, max: 320 },
        title: { min: 180, max: 520 },
        authors: { min: 170, max: 420 },
        abstract: { min: 220, max: 560 },
        note: { min: 180, max: 480 },
      };
      const bulkWidthSampleLimit = 250;
      let bulkHot = null;

      const state = {
        workspaceTab: "browser",
        viewMode: "detail",
        buckets: [],
        activeBucketId: null,
        activeFileId: null,
        loadingBuckets: false,
        bucketsError: "",
        sort: { key: "title", direction: "asc" },
        saveState: "idle",
        saveFileId: null,
        saveError: "",
        redisSummaryByFile: {},
        redisDetailCache: {},
        bulk: {
          edits: {},
          saving: false,
          status: "No pending changes.",
          error: "",
          rowFileIds: [],
        },
        autofill: {
          running: false,
          bucketId: null,
          total: 0,
          processed: 0,
          counts: {},
          message: "Ready.",
          error: "",
        },
        modal: {
          open: false,
          fileId: null,
          loading: false,
          error: "",
          items: [],
          totalAvailable: 0,
        },
        doiLookup: {
          running: false,
          fileId: null,
          message: "",
          error: "",
        },
        bucketOps: {
          running: false,
          message: "Ready.",
          error: "",
        },
        upload: {
          running: false,
          message: "",
          error: "",
          progress: 0,
          phase: "idle",
        },
        browser: {
          loading: false,
          files: [],
          visibleFiles: [],
          offset: null,
          truncated: false,
          chunkDetails: {},
          partitionChunks: {},
          openDetails: {},
          openPartitions: {},
          lastFetch: null,
          error: "",
        },
        search: {
          initialized: false,
          loading: false,
          statusOk: false,
          qdrantUrl: "",
          activeCollection: "",
          retrievalMode: "hybrid",
          results: [],
          details: {},
          meta: "Run a search to see results.",
          error: "",
        },
      };

      function bucketById(bucketId) {
        return state.buckets.find((bucket) => bucket.id === bucketId) || null;
      }

      function readCookie(name) {
        const source = String(document.cookie || "");
        if (!source) return "";
        const parts = source.split(";");
        for (const part of parts) {
          const [rawName, ...rawValue] = part.trim().split("=");
          if (rawName !== name) continue;
          const value = rawValue.join("=");
          try {
            return decodeURIComponent(value);
          } catch (_error) {
            return value;
          }
        }
        return "";
      }

      function readSelectedBucketCookie() {
        return String(readCookie(selectedBucketCookieName) || "").trim();
      }

      function writeSelectedBucketCookie(bucketId) {
        const value = String(bucketId || "").trim();
        if (!value) return;
        document.cookie =
          `${selectedBucketCookieName}=${encodeURIComponent(value)}; ` +
          `path=/; max-age=${selectedBucketCookieMaxAgeSec}; samesite=lax`;
      }

      function getActiveBucket() {
        return bucketById(state.activeBucketId);
      }

      function getActiveFile() {
        const bucket = getActiveBucket();
        if (!bucket) return null;
        return bucket.files.find((file) => file.id === state.activeFileId) || null;
      }

      function findFileById(fileId) {
        if (!fileId) return null;
        for (const bucket of state.buckets) {
          const file = bucket.files.find((entry) => entry.id === fileId);
          if (file) return file;
        }
        return null;
      }

      function isKnownEntryType(entryType) {
        return Object.prototype.hasOwnProperty.call(entryTypeRules, entryType);
      }

      function entryTypeRule(entryType) {
        const normalized = String(entryType || "").trim().toLowerCase();
        return entryTypeRules[normalized] || entryTypeRules.article;
      }

      function requiredAnyGroupsForEntryType(entryType) {
        return entryTypeRule(entryType).requiredAny || [];
      }

      function requiredSetForEntryType(entryType) {
        const set = new Set(appRequiredFields);
        const rule = entryTypeRule(entryType);
        for (const key of rule.requiredAll || []) {
          set.add(key);
        }
        for (const group of rule.requiredAny || []) {
          for (const key of group) {
            set.add(key);
          }
        }
        return set;
      }

      function recommendedSetForEntryType(entryType) {
        return new Set(entryTypeRule(entryType).recommended || []);
      }

      function displayFieldName(key) {
        if (key === "authors") return "Authors";
        if (key === "editors") return "Editors";
        if (key === "entryType") return "Entry Type";
        if (key === "citationKey") return "Citation Key";
        if (key === "booktitle") return "Booktitle";
        if (key === "howpublished") return "How Published";
        return String(key || "")
          .replace(/([A-Z])/g, " $1")
          .replace(/^./, (char) => char.toUpperCase());
      }

      function createFieldLabel(text, { required = false, recommended = false } = {}) {
        const label = document.createElement("label");
        label.className = "field-label";
        label.textContent = text;
        if (required) {
          const badge = document.createElement("span");
          badge.className = "required-badge";
          badge.textContent = "Required";
          label.append(badge);
        } else if (recommended) {
          const badge = document.createElement("span");
          badge.className = "recommended-badge";
          badge.textContent = "Recommended";
          label.append(badge);
        }
        return label;
      }

      function coerceAuthors(file) {
        if (!Array.isArray(file.authors)) {
          if (typeof file.authors === "string" && file.authors.trim()) {
            const parts = file.authors
              .split(",")
              .map((entry) => entry.trim())
              .filter(Boolean);
            file.authors = parts.map((lastName) => ({ firstName: "", lastName }));
          } else {
            file.authors = [];
          }
        }

        for (let idx = 0; idx < file.authors.length; idx += 1) {
          const author = file.authors[idx];
          if (author && typeof author === "object") {
            let firstName = typeof author.firstName === "string" ? author.firstName : "";
            let lastName = typeof author.lastName === "string" ? author.lastName : "";
            if (!firstName && typeof author.given === "string") firstName = author.given;
            if (!firstName && typeof author.givenName === "string") firstName = author.givenName;
            if (!lastName && typeof author.family === "string") lastName = author.family;
            if (!lastName && typeof author.familyName === "string") lastName = author.familyName;
            if (!firstName && !lastName) {
              const fullName =
                typeof author.name === "string"
                  ? author.name
                  : typeof author.literal === "string"
                    ? author.literal
                    : "";
              const parts = String(fullName)
                .trim()
                .split(/\s+/)
                .filter(Boolean);
              if (parts.length === 1) {
                lastName = parts[0];
              } else if (parts.length > 1) {
                firstName = parts.slice(0, -1).join(" ");
                lastName = parts[parts.length - 1];
              }
            }
            author.firstName = String(firstName || "");
            author.lastName = String(lastName || "");
            continue;
          }
          if (typeof author === "string") {
            file.authors[idx] = { firstName: "", lastName: author };
            continue;
          }
          file.authors[idx] = { firstName: "", lastName: "" };
        }
        return file.authors;
      }

      function hasIncompleteAuthorRows(authors) {
        return (authors || []).some(
          (author) => String(author?.firstName || "").trim() && !String(author?.lastName || "").trim()
        );
      }

      function initialsFromFirstName(firstName) {
        const parts = String(firstName || "")
          .trim()
          .split(/\s+/)
          .filter(Boolean);
        return parts
          .map((part) =>
            part
              .split("-")
              .filter(Boolean)
              .map((subpart) => `${subpart.charAt(0).toUpperCase()}.`)
              .join("-")
          )
          .join(" ");
      }

      function formatAuthorApa(author) {
        const lastName = String(author?.lastName || "").trim();
        const initials = initialsFromFirstName(author?.firstName || "");
        if (lastName && initials) return `${lastName}, ${initials}`;
        if (lastName) return lastName;
        if (initials) return initials;
        return "";
      }

      function formatAuthorsApa(authors) {
        const formatted = authors.map(formatAuthorApa).filter(Boolean);
        if (formatted.length === 0) return "";
        if (formatted.length === 1) return formatted[0];
        if (formatted.length === 2) return `${formatted[0]} & ${formatted[1]}`;
        return `${formatted.slice(0, -1).join(", ")}, & ${formatted[formatted.length - 1]}`;
      }

      function displayTitle(file) {
        return String(file?.title || "").trim() || String(file?.fileName || "").trim() || "—";
      }

      function displaySource(file) {
        const entryType = String(file?.entryType || "").trim().toLowerCase();
        const journal = String(file?.journal || "").trim();
        const booktitle = String(file?.booktitle || "").trim();
        const publisher = String(file?.publisher || "").trim();

        if (entryType === "article") return journal || booktitle || publisher;
        if (entryType === "inproceedings" || entryType === "inbook" || entryType === "incollection") {
          return booktitle || journal || publisher;
        }
        if (entryType === "book") return booktitle || publisher || journal;
        return journal || booktitle || publisher;
      }

      function normalizeFileRecord(raw) {
        const file = { ...defaultFileFields, ...(raw || {}) };
        file.bucket = String(file.bucket || "");
        file.objectName = String(file.objectName || "");
        file.fileName = String(file.fileName || file.objectName.split("/").pop() || "unknown");
        file.id = String(file.id || `${file.bucket}/${file.objectName}` || file.fileName);
        if (!Array.isArray(file.redisDocIds)) {
          file.redisDocIds = file.redisDocId ? [String(file.redisDocId)] : [];
        } else {
          file.redisDocIds = file.redisDocIds.map((entry) => String(entry || "")).filter(Boolean);
        }
        file.redisDocId = String(file.redisDocId || file.redisDocIds[0] || "");
        file.entryType = isKnownEntryType(file.entryType) ? file.entryType : "article";
        for (const key of Object.keys(defaultFileFields)) {
          if (key === "authors") continue;
          file[key] = file[key] == null ? "" : String(file[key]);
        }
        coerceAuthors(file);
        return file;
      }

      function setViewMode(mode) {
        if (mode !== "bulk" && mode !== "detail") return;
        if (state.viewMode === "bulk" && mode !== "bulk") {
          finalizeBulkEditing();
        }
        state.viewMode = mode;
        if (mode === "detail") {
          const activeBucket = getActiveBucket();
          if (activeBucket && activeBucket.loaded && !state.activeFileId && activeBucket.files.length > 0) {
            state.activeFileId = activeBucket.files[0].id;
          }
        }
        renderAll();
      }

      function setWorkspaceTab(tab) {
        if (tab !== "browser" && tab !== "bibtex" && tab !== "search") return;
        if (state.workspaceTab === tab) return;
        if (tab !== "bibtex" && state.viewMode === "bulk") {
          finalizeBulkEditing();
        }
        state.workspaceTab = tab;
        renderAll();
        if (tab === "search") {
          ensureSearchWorkspaceLoaded();
        }
        if (tab === "browser") {
          if (state.activeBucketId) {
            browserLoadFiles({ reset: true });
          }
        }
      }

      function bulkFilesForBucket(bucket) {
        if (!bucket || !Array.isArray(bucket.files)) return [];
        return [...bucket.files].sort((left, right) =>
          String(left.objectName || "").localeCompare(String(right.objectName || ""), undefined, {
            numeric: true,
            sensitivity: "base",
          })
        );
      }

      function bulkFilesForActiveBucket() {
        return bulkFilesForBucket(getActiveBucket());
      }

      function authorsToBulkText(file) {
        const authors = coerceAuthors(file);
        const names = authors
          .map((author) => [author.firstName, author.lastName].filter(Boolean).join(" ").trim())
          .filter(Boolean);
        return names.join("; ");
      }

      function parseBulkAuthors(value) {
        const text = String(value || "").trim();
        if (!text) return [];
        const rawParts = text
          .replace(/\band\b/gi, ";")
          .split(/[;\n]/)
          .map((entry) => entry.trim())
          .filter(Boolean);
        return rawParts.map((entry) => {
          const parts = entry.split(/\s+/).filter(Boolean);
          if (parts.length <= 1) {
            return { firstName: "", lastName: parts[0] || "" };
          }
          return { firstName: parts.slice(0, -1).join(" "), lastName: parts[parts.length - 1] };
        });
      }

      function bulkBaselineValue(file, key) {
        if (key === "minioPath") return `${file.bucket}/${file.objectName}`;
        if (key === "redisDocId") return String(file.redisDocId || "");
        if (key === "authors") return authorsToBulkText(file);
        return String(file?.[key] ?? "");
      }

      function getBulkEditsForFile(fileId) {
        return state.bulk.edits[fileId] || {};
      }

      function getBulkCellValue(file, key) {
        const edits = getBulkEditsForFile(file.id);
        if (Object.prototype.hasOwnProperty.call(edits, key)) {
          return String(edits[key] ?? "");
        }
        return bulkBaselineValue(file, key);
      }

      function updateBulkStatusText() {
        if (state.bulk.saving) {
          return;
        }
        const pendingFiles = Object.keys(state.bulk.edits).length;
        if (pendingFiles === 0) {
          state.bulk.status = "No pending changes.";
          state.bulk.error = "";
          return;
        }
        state.bulk.status = `${pendingFiles} file(s) pending save.`;
      }

      function setBulkCellValue(file, key, value) {
        if (!file || !file.id || key === "minioPath" || key === "redisDocId") return;
        const normalized = String(value ?? "");
        const baseline = bulkBaselineValue(file, key);
        const rowEdits = { ...getBulkEditsForFile(file.id) };
        if (normalized === baseline) {
          delete rowEdits[key];
        } else {
          rowEdits[key] = normalized;
        }

        if (Object.keys(rowEdits).length === 0) {
          delete state.bulk.edits[file.id];
        } else {
          state.bulk.edits[file.id] = rowEdits;
        }
        updateBulkStatusText();
      }

      function destroyBulkHot() {
        if (!bulkHot) return;
        bulkHot.destroy();
        bulkHot = null;
      }

      function finalizeBulkEditing() {
        if (!bulkHot) return;
        const editor = bulkHot.getActiveEditor?.();
        if (editor && editor.isOpened?.()) {
          editor.finishEditing();
        }
      }

      function setBulkHotMessage(message) {
        const messageEl = document.getElementById("bulkHotMessage");
        if (!messageEl) return;
        const text = String(message || "").trim();
        messageEl.hidden = !text;
        messageEl.textContent = text;
      }

      function bulkRowData(file) {
        const row = {};
        for (const column of bulkColumns) {
          row[column.key] = getBulkCellValue(file, column.key);
        }
        return row;
      }

      function clampBulkWidth(value, key) {
        const config = bulkWidthByColumn[key] || bulkWidthDefaults;
        const min = Number(config.min || bulkWidthDefaults.min);
        const max = Number(config.max || bulkWidthDefaults.max);
        return Math.max(min, Math.min(max, value));
      }

      function estimateBulkColumnWidth(key, label, files) {
        const sampleCount = Math.min(files.length, bulkWidthSampleLimit);
        let maxChars = String(label || "").length;
        for (let idx = 0; idx < sampleCount; idx += 1) {
          const file = files[idx];
          const value = String(getBulkCellValue(file, key) || "")
            .replace(/\s+/g, " ")
            .trim();
          if (!value) continue;
          const charCount = Math.min(value.length, 120);
          if (charCount > maxChars) {
            maxChars = charCount;
          }
        }

        const estimatedPixels = Math.round(maxChars * 7.4 + 34);
        return clampBulkWidth(estimatedPixels, key);
      }

      function bulkColumnWidths(files) {
        return bulkColumns.map((column) =>
          estimateBulkColumnWidth(column.key, column.label, files || [])
        );
      }

      function syncBulkEditsFromHotChanges(changes) {
        if (!Array.isArray(changes) || changes.length === 0) return;
        for (const change of changes) {
          const [row, prop, _oldValue, newValue] = change;
          const key = String(prop || "");
          if (!key) continue;
          const column = bulkColumns.find((entry) => entry.key === key);
          if (!column || column.readOnly) continue;
          const fileId = state.bulk.rowFileIds[row];
          const file = findFileById(fileId);
          if (!file) continue;
          setBulkCellValue(file, key, newValue);
        }
      }

      function ensureBulkHot(container) {
        if (bulkHot) return bulkHot;
        const HandsontableLib = window.Handsontable;
        if (!HandsontableLib || !container) return null;

        bulkHot = new HandsontableLib(container, {
          data: [],
          columns: bulkColumns.map((column) => ({
            data: column.key,
            readOnly: !!column.readOnly,
          })),
          colHeaders: bulkColumns.map((column) => column.label),
          colWidths: bulkColumnWidths([]),
          rowHeaders: false,
          width: "100%",
          height: 520,
          stretchH: "none",
          contextMenu: true,
          manualColumnResize: true,
          copyPaste: true,
          autoWrapRow: false,
          autoWrapCol: false,
          licenseKey: "non-commercial-and-evaluation",
          afterChange(changes, source) {
            if (source === "loadData" || source === "updateSettings") return;
            syncBulkEditsFromHotChanges(changes);
            renderBulkStatusAndActions();
          },
        });

        return bulkHot;
      }

      function renderBulkHotGrid(files) {
        const container = document.getElementById("bulkHot");
        if (!container) return;
        const hot = ensureBulkHot(container);
        if (!hot) {
          state.bulk.rowFileIds = [];
          setBulkHotMessage("Handsontable failed to load. Check network access to jsdelivr.");
          return;
        }

        state.bulk.rowFileIds = files.map((file) => file.id);
        const rows = files.map((file) => bulkRowData(file));
        hot.updateSettings({ colWidths: bulkColumnWidths(files) });
        hot.loadData(rows);
      }

      function hasRequiredCoreMetadata(file) {
        if (!file) return false;
        const hasTitle = String(file.title || "").trim().length > 0;
        const hasDoi = String(file.doi || "").trim().length > 0;
        const authors = coerceAuthors(file);
        const hasAuthors = authors.some(
          (author) => String(author.firstName || "").trim() || String(author.lastName || "").trim()
        );
        return hasTitle && hasDoi && hasAuthors;
      }

      function autofillObjectNames(bucket) {
        if (!bucket || !Array.isArray(bucket.files)) return [];
        const names = [];
        for (const file of bucket.files) {
          if (!file?.objectName || hasRequiredCoreMetadata(file)) continue;
          names.push(String(file.objectName));
        }
        return names;
      }

      function resetAutofillState(message = "Ready.") {
        state.autofill.running = false;
        state.autofill.bucketId = null;
        state.autofill.total = 0;
        state.autofill.processed = 0;
        state.autofill.counts = {};
        state.autofill.message = message;
        state.autofill.error = "";
      }

      function applyAutofillResults(bucketId, results) {
        const bucket = bucketById(bucketId);
        if (!bucket || !Array.isArray(results)) return;
        for (const item of results) {
          const objectName = String(item?.objectName || "");
          const incomingFile = item?.file;
          if (!objectName || !incomingFile) continue;
          const idx = bucket.files.findIndex((file) => file.objectName === objectName);
          if (idx < 0) continue;
          bucket.files[idx] = normalizeFileRecord(incomingFile);
        }
      }

      function mergeAutofillCounts(counts) {
        if (!counts || typeof counts !== "object") return;
        for (const [key, value] of Object.entries(counts)) {
          const numericValue = Number(value || 0);
          state.autofill.counts[key] = Number(state.autofill.counts[key] || 0) + numericValue;
        }
      }

      async function runAutofillMissing() {
        const bucket = getActiveBucket();
        if (!bucket || bucket.loading || state.autofill.running) return;
        const targetObjectNames = autofillObjectNames(bucket);
        resetAutofillState();
        state.autofill.bucketId = bucket.id;
        state.autofill.total = targetObjectNames.length;
        state.autofill.message = "Preparing autofill run...";
        renderAll();

        if (targetObjectNames.length === 0) {
          state.autofill.message = "No files with missing core metadata.";
          renderAll();
          return;
        }

        state.autofill.running = true;
        state.autofill.message = "Running autofill in batches...";
        renderAll();

        let offset = 0;
        while (offset < targetObjectNames.length) {
          try {
            const data = await apiRequest(`/api/buckets/${encodeURIComponent(bucket.id)}/autofill-missing`, {
              method: "POST",
              body: JSON.stringify({
                objectNames: targetObjectNames,
                offset,
                batchSize: autofillBatchSize,
                dryRun: false,
              }),
            });
            offset = Number(data.next_offset ?? data.processed_total ?? targetObjectNames.length);
            state.autofill.processed = Number(data.processed_total || offset);
            mergeAutofillCounts(data.counts || {});
            applyAutofillResults(bucket.id, data.results || []);
            state.autofill.message = `Processed ${state.autofill.processed} of ${state.autofill.total}.`;
            renderAll();
          } catch (error) {
            state.autofill.error = String(error.message || error);
            state.autofill.message = `Autofill failed: ${state.autofill.error}`;
            break;
          }
        }

        state.autofill.running = false;
        if (!state.autofill.error) {
          const updatedCount = Number(state.autofill.counts.updated || 0);
          const skippedCount = Number(state.autofill.counts.skipped_existing || 0);
          const lowConfidenceCount = Number(state.autofill.counts.low_confidence || 0);
          const conflictCount = Number(state.autofill.counts.doi_conflict || 0);
          state.autofill.message =
            `Done. Updated ${updatedCount} file(s), skipped ${skippedCount}, low confidence ${lowConfidenceCount}, DOI conflicts ${conflictCount}.`;
        }
        renderAll();
      }

      function sleep(ms) {
        return new Promise((resolve) => {
          window.setTimeout(resolve, ms);
        });
      }

      async function uploadFormRequest(path, formData, onProgress) {
        return new Promise((resolve, reject) => {
          const xhr = new XMLHttpRequest();
          xhr.open("POST", rewriteApiRequestUrl(path), true);
          xhr.upload.onprogress = (event) => {
            if (!event.lengthComputable) return;
            if (typeof onProgress === "function") {
              onProgress(event.loaded, event.total);
            }
          };
          xhr.onerror = () => reject(new Error("Network error while uploading file."));
          xhr.onload = () => {
            const text = String(xhr.responseText || "");
            let payload = null;
            if (text) {
              try {
                payload = JSON.parse(text);
              } catch (_error) {
                payload = null;
              }
            }
            if (xhr.status < 200 || xhr.status >= 300) {
              const detail = payload?.detail || text || `HTTP ${xhr.status}`;
              reject(new Error(detail));
              return;
            }
            resolve(payload || {});
          };
          xhr.send(formData);
        });
      }

      async function refreshBucketData(bucketId, preferredObjectName = "") {
        const bucket = bucketById(bucketId);
        if (!bucket) return;
        bucket.loaded = false;
        bucket.loading = false;
        bucket.error = "";
        await ensureBucketLoaded(bucketId);
        if (preferredObjectName) {
          const refreshed = bucketById(bucketId);
          const match = refreshed?.files.find((entry) => entry.objectName === preferredObjectName);
          if (match) {
            state.activeFileId = match.id;
          }
        }
      }

      function closeAddBucketModal() {
        const modal = document.getElementById("addBucketModal");
        const input = document.getElementById("addBucketModalInput");
        if (modal) modal.hidden = true;
        if (input) input.value = "";
      }

      function openAddBucketModal() {
        if (state.bucketOps.running) return;
        const modal = document.getElementById("addBucketModal");
        const input = document.getElementById("addBucketModalInput");
        if (!modal || !input) return;
        modal.hidden = false;
        window.setTimeout(() => {
          input.focus();
          input.select();
        }, 0);
      }

      function closeDeleteBucketModal() {
        const modal = document.getElementById("deleteBucketModal");
        const confirmBtn = document.getElementById("deleteBucketConfirmBtn");
        if (modal) modal.hidden = true;
        if (confirmBtn) {
          confirmBtn.removeAttribute("data-bucket-id");
        }
      }

      function openDeleteBucketModal() {
        if (state.bucketOps.running) return;
        const bucket = getActiveBucket();
        if (!bucket) {
          state.bucketOps.error = "Select a bucket first.";
          state.bucketOps.message = "Select a bucket first.";
          renderAll();
          return;
        }
        const modal = document.getElementById("deleteBucketModal");
        const text = document.getElementById("deleteBucketModalText");
        const confirmBtn = document.getElementById("deleteBucketConfirmBtn");
        if (!modal || !text || !confirmBtn) return;
        text.textContent = `Delete bucket "${bucket.name}" and all files in it?`;
        confirmBtn.setAttribute("data-bucket-id", bucket.id);
        modal.hidden = false;
      }

      async function addBucketByName(rawName) {
        const raw = String(rawName || "").trim();
        if (!raw) {
          state.bucketOps.error = "Bucket name is required.";
          state.bucketOps.message = "Bucket name is required.";
          renderAll();
          return false;
        }
        state.bucketOps.running = true;
        state.bucketOps.error = "";
        state.bucketOps.message = `Creating bucket "${raw}"...`;
        renderAll();
        try {
          await apiRequest("/api/buckets", {
            method: "POST",
            body: JSON.stringify({ bucket: raw }),
          });
          await loadBuckets();
          if (bucketById(raw)) {
            selectBucket(raw);
          }
          state.bucketOps.message = `Bucket ready: ${raw}`;
          state.bucketOps.error = "";
          return true;
        } catch (error) {
          state.bucketOps.error = String(error.message || error);
          state.bucketOps.message = `Bucket create failed: ${state.bucketOps.error}`;
          return false;
        } finally {
          state.bucketOps.running = false;
          renderAll();
        }
      }

      async function confirmAddBucketFromModal() {
        const input = document.getElementById("addBucketModalInput");
        const raw = input ? String(input.value || "").trim() : "";
        const ok = await addBucketByName(raw);
        if (ok) {
          closeAddBucketModal();
        }
      }

      async function deleteBucketById(bucketId) {
        const normalizedBucketId = String(bucketId || "").trim();
        if (!normalizedBucketId || state.bucketOps.running) return false;
        const bucket = bucketById(normalizedBucketId);
        const bucketName = String(bucket?.name || normalizedBucketId);
        state.bucketOps.running = true;
        state.bucketOps.error = "";
        state.bucketOps.message = `Deleting bucket "${bucketName}"...`;
        renderAll();
        try {
          await apiRequest(
            `/api/buckets/${encodeURIComponent(normalizedBucketId)}?force=true&delete_ingested=false`,
            { method: "DELETE" }
          );
          await loadBuckets();
          state.bucketOps.message = `Deleted bucket: ${bucketName}`;
          state.bucketOps.error = "";
          return true;
        } catch (error) {
          state.bucketOps.error = String(error.message || error);
          state.bucketOps.message = `Bucket delete failed: ${state.bucketOps.error}`;
          return false;
        } finally {
          state.bucketOps.running = false;
          renderAll();
        }
      }

      async function confirmDeleteBucketFromModal() {
        const confirmBtn = document.getElementById("deleteBucketConfirmBtn");
        if (!confirmBtn) return;
        const bucketId = String(confirmBtn.getAttribute("data-bucket-id") || "").trim();
        const ok = await deleteBucketById(bucketId);
        if (ok) {
          closeDeleteBucketModal();
        }
      }

      function closeUploadModal() {
        const modal = document.getElementById("uploadModal");
        const filesInput = document.getElementById("uploadModalFilesInput");
        if (modal) modal.hidden = true;
        if (filesInput) filesInput.value = "";
      }

      function openUploadModal() {
        const bucket = getActiveBucket();
        if (!bucket) {
          state.upload.error = "Select a bucket first.";
          state.upload.message = "Select a bucket first.";
          renderAll();
          return;
        }
        if (state.upload.running) return;
        const modal = document.getElementById("uploadModal");
        const filesInput = document.getElementById("uploadModalFilesInput");
        if (!modal || !filesInput) return;
        modal.hidden = false;
        window.setTimeout(() => {
          filesInput.focus();
        }, 0);
      }

      async function pollIngestJob(jobId) {
        while (true) {
          const payload = await apiRequest(`/api/ingest-jobs/${encodeURIComponent(jobId)}`);
          const status = String(payload.status || "").toLowerCase();
          const serverProgress = Number(payload.progress || 0);
          state.upload.phase = status || "ingesting";
          state.upload.progress = Math.max(55, Math.min(99, serverProgress || 55));
          state.upload.message = String(payload.message || "Running ingest...");
          state.upload.error = "";
          renderAll();
          if (status === "completed") {
            state.upload.phase = "completed";
            state.upload.progress = 100;
            state.upload.message = String(payload.message || "Ingest completed.");
            return payload;
          }
          if (status === "failed") {
            const detail = String(payload.error || payload.message || "Ingest failed.");
            throw new Error(detail);
          }
          await sleep(ingestPollDelayMs);
        }
      }

      async function uploadFileToActiveBucket() {
        const bucket = getActiveBucket();
        const filesInput = document.getElementById("uploadModalFilesInput");
        if (!bucket || !filesInput) return;
        if (state.upload.running || bucket.loading) return;

        const files = filesInput.files ? Array.from(filesInput.files) : [];
        if (files.length === 0) {
          state.upload.error = "Choose at least one PDF file to upload.";
          state.upload.message = "Choose at least one PDF file to upload.";
          renderAll();
          return;
        }
        const invalid = files.find((entry) => !String(entry.name || "").toLowerCase().endsWith(".pdf"));
        if (invalid) {
          state.upload.error = `Only PDF files are supported: ${invalid.name}`;
          state.upload.message = state.upload.error;
          renderAll();
          return;
        }

        const formData = new FormData();
        for (const entry of files) {
          formData.append("files", entry);
        }
        formData.append("create_bucket", "false");

        state.upload.running = true;
        state.upload.phase = "uploading";
        state.upload.progress = 1;
        state.upload.error = "";
        state.upload.message = `Uploading ${files.length} PDF file(s)...`;
        renderAll();

        try {
          const payload = await uploadFormRequest(
            `/api/buckets/${encodeURIComponent(bucket.id)}/files/upload`,
            formData,
            (loaded, total) => {
              if (!total) return;
              const percent = Math.max(1, Math.min(65, Math.round((loaded / total) * 65)));
              state.upload.phase = "uploading";
              state.upload.progress = percent;
              state.upload.message = `Uploading ${files.length} file(s)...`;
              renderUploadControls();
            }
          );

          const uploaded = Array.isArray(payload.uploaded) ? payload.uploaded : [];
          const uploadedCount = Number(payload.uploaded_count || uploaded.length || files.length);
          state.upload.progress = 70;
          state.upload.phase = "uploaded";
          state.upload.message = "Upload complete. Starting ingest...";
          renderAll();

          const jobId = String(payload.job_id || "").trim();
          const queuedCount = Number(payload.queued_count || 0);
          if (jobId) {
            await pollIngestJob(jobId);
          } else if (uploadedCount > 1) {
            state.upload.phase = "queued";
            state.upload.progress = 100;
            state.upload.message = `Uploaded ${uploadedCount} file(s). Queued ${queuedCount} ingest task(s) in Celery.`;
            const queueErrors = Array.isArray(payload.queue_errors) ? payload.queue_errors : [];
            state.upload.error = queueErrors.length > 0 ? String(queueErrors[0]) : "";
          } else {
            state.upload.phase = "completed";
            state.upload.progress = 100;
            state.upload.message = `Upload complete (${uploadedCount} file(s)).`;
          }

          await refreshBucketData(bucket.id);
          if (!state.upload.error) {
            closeUploadModal();
          }
        } catch (error) {
          state.upload.phase = "failed";
          state.upload.progress = 100;
          state.upload.error = String(error.message || error);
          state.upload.message = `Upload failed: ${state.upload.error}`;
        } finally {
          state.upload.running = false;
          renderAll();
        }
      }

      async function deleteFileFromBucket(file) {
        if (!file || !file.bucket || !file.objectName) return;
        const confirmed = window.confirm(
          `Remove "${file.fileName}" from bucket "${file.bucket}"? Redis data will be preserved.`
        );
        if (!confirmed) return;
        try {
          await apiRequest(
            `/api/buckets/${encodeURIComponent(file.bucket)}/files/${encodeObjectPath(file.objectName)}?delete_ingested=false`,
            { method: "DELETE" }
          );
          const bucket = bucketById(file.bucket);
          if (bucket) {
            bucket.files = bucket.files.filter((entry) => entry.id !== file.id);
            if (state.activeFileId === file.id) {
              state.activeFileId = bucket.files.length > 0 ? bucket.files[0].id : null;
            }
          }
          delete state.redisSummaryByFile[file.id];
          delete state.redisDetailCache[file.id];
          state.bucketOps.error = "";
          state.bucketOps.message = `Removed file: ${file.fileName}`;
          renderAll();
        } catch (error) {
          state.bucketOps.error = String(error.message || error);
          state.bucketOps.message = `File delete failed: ${state.bucketOps.error}`;
          renderAll();
        }
      }

      async function apiRequest(path, options = {}) {
        const requestOptions = {
          ...options,
          headers: {
            "Content-Type": "application/json",
            ...(options.headers || {}),
          },
        };
        const response = await fetch(path, requestOptions);
        const text = await response.text();
        let payload = null;
        if (text) {
          try {
            payload = JSON.parse(text);
          } catch (_err) {
            payload = null;
          }
        }
        if (!response.ok) {
          const detail = payload?.detail || text || `HTTP ${response.status}`;
          throw new Error(detail);
        }
        return payload || {};
      }

      function encodeObjectPath(objectName) {
        return String(objectName)
          .split("/")
          .map((part) => encodeURIComponent(part))
          .join("/");
      }

      function browserEsc(value) {
        return String(value ?? "")
          .replaceAll("&", "&amp;")
          .replaceAll("<", "&lt;")
          .replaceAll(">", "&gt;");
      }

      function browserEscAttr(value) {
        return browserEsc(value).replaceAll('"', "&quot;").replaceAll("'", "&#39;");
      }

      function browserFmt(value) {
        return value === null || value === undefined ? "-" : String(value);
      }

      function browserSourceLabel(file) {
        if (file.source) return file.source;
        if (file.bucket || file.key) {
          return `${file.bucket || state.activeBucketId || ""}${file.key ? `/${file.key}` : ""}`;
        }
        return "-";
      }

      function browserFileLabel(file) {
        if (file.key) return file.key;
        if (file.source) return file.source;
        if (file.document_id) return file.document_id;
        return "-";
      }

      function browserFileIdentityKey(file) {
        if (file.document_id) return `doc:${file.document_id}`;
        if (file.source) return `source:${file.source}`;
        return `object:${file.bucket || state.activeBucketId || ""}/${file.key || ""}`;
      }

      function browserDetailsCacheKey(file) {
        return `${state.activeBucketId || ""}|${browserFileIdentityKey(file)}`;
      }

      function browserPartitionChunkCacheKey(file, partitionIndex) {
        return `${browserDetailsCacheKey(file)}|partition:${partitionIndex}`;
      }

      function browserTopLevelChunks(file) {
        return file.qdrant_chunks ?? file.redis_chunks ?? null;
      }

      function browserTopLevelPartitions(file) {
        return file.qdrant_partitions ?? file.redis_partitions ?? null;
      }

      function browserMatchesSearch(file, searchText) {
        if (!searchText) return true;
        const haystack = [
          file.key,
          file.source,
          file.document_id,
          Array.isArray(file.redis_doc_ids) ? file.redis_doc_ids.join(",") : "",
        ]
          .filter(Boolean)
          .join(" ")
          .toLowerCase();
        return haystack.includes(searchText);
      }

      function browserCompareBySource(left, right) {
        return browserSourceLabel(left).toLowerCase().localeCompare(browserSourceLabel(right).toLowerCase());
      }

      function browserChunkPagesLabel(chunk) {
        if (chunk.page_start !== null && chunk.page_start !== undefined) {
          const end = chunk.page_end !== null && chunk.page_end !== undefined ? chunk.page_end : chunk.page_start;
          return end === chunk.page_start ? `Page ${chunk.page_start}` : `Pages ${chunk.page_start}-${end}`;
        }
        if (Array.isArray(chunk.pages) && chunk.pages.length > 0) {
          const min = Math.min(...chunk.pages);
          const max = Math.max(...chunk.pages);
          return min === max ? `Page ${min}` : `Pages ${min}-${max}`;
        }
        return "Unknown pages";
      }

      function browserDetailJson(value) {
        if (
          !value ||
          (typeof value === "object" && !Array.isArray(value) && Object.keys(value).length === 0)
        ) {
          return "No metadata available.";
        }
        return JSON.stringify(value, null, 2);
      }

      function browserMergedRedisMetadata(file) {
        return file.redis_metadata || {};
      }

      function browserMergedQdrantMetadata(file) {
        const base = {
          qdrant_chunks: file.qdrant_chunks ?? null,
          bucket: file.bucket || state.activeBucketId || null,
          key: file.key || null,
          source: file.source || null,
          document_id: file.document_id || null,
          version_id: file.version_id || null,
          pages:
            file.page_start !== undefined && file.page_start !== null
              ? `${file.page_start}-${file.page_end ?? file.page_start}`
              : "-",
        };
        return Object.assign(base, file.qdrant_metadata || {});
      }

      function browserFindFileByCacheKey(cacheKey) {
        return (
          state.browser.visibleFiles.find((file) => browserDetailsCacheKey(file) === cacheKey) ||
          state.browser.files.find((file) => browserDetailsCacheKey(file) === cacheKey) ||
          null
        );
      }

      function browserPartitionChunksHtml(file, partitionIndex) {
        const cache = state.browser.partitionChunks[browserPartitionChunkCacheKey(file, partitionIndex)];
        if (!cache) return `<div class="pane-subtitle">Expand partition to load chunks.</div>`;
        if (cache.loading) return `<div class="pane-subtitle">Loading chunks...</div>`;
        if (cache.error) return `<div class="pane-subtitle">Failed to load chunks: ${browserEsc(cache.error)}</div>`;
        const chunks = cache.data?.partition?.chunks || [];
        if (!chunks.length) return `<div class="pane-subtitle">No chunks found.</div>`;
        return chunks
          .map(
            (chunk) => `
          <div class="browser-chunk">
            <div class="browser-chunk-meta">Chunk ${browserFmt(chunk.chunk_index)} | ${browserEsc(browserChunkPagesLabel(chunk))}</div>
            <pre class="browser-chunk-text">${browserEsc(chunk.text || "")}</pre>
          </div>
        `
          )
          .join("");
      }

      function browserChunkDetailsHtml(file) {
        const cache = state.browser.chunkDetails[browserDetailsCacheKey(file)];
        if (!cache) return `<div class="pane-subtitle">Expand to load chunk text grouped by partition.</div>`;
        if (cache.loading) return `<div class="pane-subtitle">Loading chunk details...</div>`;
        if (cache.error) {
          return `<div class="pane-subtitle">Failed to load chunk details: ${browserEsc(cache.error)}</div>`;
        }
        const partitions = cache.data?.partitions || [];
        if (!partitions.length) return `<div class="pane-subtitle">No chunk data found.</div>`;
        const fileKey = browserDetailsCacheKey(file);
        return partitions
          .map((partition) => {
            const partitionTitle = `Partition ${partition.partition_index} | ${partition.label} | ${partition.chunk_count} chunks`;
            const partitionCacheKey = browserPartitionChunkCacheKey(file, partition.partition_index);
            const isOpen = !!state.browser.openPartitions[partitionCacheKey];
            return `
            <details
              class="browser-partition-group"
              data-file-key="${browserEscAttr(fileKey)}"
              data-partition-index="${partition.partition_index}"
              ${isOpen ? "open" : ""}
              ontoggle="browserTogglePartition(event)"
            >
              <summary>${browserEsc(partitionTitle)}</summary>
              <div class="browser-partition-body" data-file-key="${browserEscAttr(fileKey)}" data-partition-index="${partition.partition_index}">
                ${browserPartitionChunksHtml(file, partition.partition_index)}
              </div>
            </details>
          `;
          })
          .join("");
      }

      function browserDetailSectionsHtml(file) {
        const redisJson = browserEsc(browserDetailJson(browserMergedRedisMetadata(file)));
        const qdrantJson = browserEsc(browserDetailJson(browserMergedQdrantMetadata(file)));
        return `
          <div class="browser-meta-card">
            <details class="browser-meta-section">
              <summary>Redis metadata</summary>
              <div class="browser-meta-body">
                <pre class="browser-json">${redisJson}</pre>
              </div>
            </details>
            <details class="browser-meta-section">
              <summary>Qdrant metadata</summary>
              <div class="browser-meta-body">
                <pre class="browser-json">${qdrantJson}</pre>
              </div>
            </details>
            <details class="browser-meta-section" open>
              <summary>Chunk text by partition</summary>
              <div class="browser-meta-body">
                ${browserChunkDetailsHtml(file)}
              </div>
            </details>
          </div>
        `;
      }

      function browserSetRedisStatus(files) {
        const dot = document.getElementById("browserRedisDot");
        const label = document.getElementById("browserRedisStatus");
        if (!dot || !label) return;
        if (!state.activeBucketId) {
          dot.className = "browser-dot";
          label.textContent = "Redis: unknown";
          return;
        }
        const hasRedis = files.some(
          (file) =>
            file.redis_chunks !== undefined || file.redis_partitions !== undefined || file.redis_meta_key
        );
        if (hasRedis) {
          dot.className = "browser-dot good";
          label.textContent = "Redis: connected";
        } else {
          dot.className = "browser-dot warn";
          label.textContent = "Redis: not configured / no matches";
        }
      }

      function browserUpdateVisibleRowsByCacheKey(cacheKey) {
        for (let idx = 0; idx < state.browser.visibleFiles.length; idx += 1) {
          const file = state.browser.visibleFiles[idx];
          if (browserDetailsCacheKey(file) !== cacheKey) continue;
          const summaryRow = document.getElementById(`browser-summary-${idx}`);
          const detailsRow = document.getElementById(`browser-details-${idx}`);
          if (!summaryRow || !detailsRow) continue;
          const cells = summaryRow.querySelectorAll("td");
          if (cells.length >= 3) {
            cells[1].textContent = browserFmt(browserTopLevelPartitions(file));
            cells[2].textContent = browserFmt(browserTopLevelChunks(file));
          }
          const detailsCell = detailsRow.querySelector(".browser-details-cell");
          if (detailsCell) {
            detailsCell.innerHTML = browserDetailSectionsHtml(file);
          }
        }
      }

      function browserUpdatePartitionBodies(fileKey, partitionIndex) {
        const file = browserFindFileByCacheKey(fileKey);
        if (!file) return;
        const html = browserPartitionChunksHtml(file, partitionIndex);
        const nodes = document.querySelectorAll(".browser-partition-body");
        for (const node of nodes) {
          const nodeFileKey = node.getAttribute("data-file-key") || "";
          const nodePartitionIndex = Number.parseInt(node.getAttribute("data-partition-index") || "", 10);
          if (nodeFileKey === fileKey && nodePartitionIndex === partitionIndex) {
            node.innerHTML = html;
          }
        }
      }

      async function browserLoadChunkDetails(file) {
        if (!state.activeBucketId) return;
        const cacheKey = browserDetailsCacheKey(file);
        const cache = state.browser.chunkDetails[cacheKey];
        if (cache && (cache.loading || cache.data || cache.error)) return;

        state.browser.chunkDetails[cacheKey] = { loading: true };
        browserUpdateVisibleRowsByCacheKey(cacheKey);
        try {
          const url = new URL(
            `/api/dashboard/buckets/${encodeURIComponent(state.activeBucketId)}/files/partitions`,
            window.location.origin
          );
          if (file.document_id) {
            url.searchParams.set("document_id", file.document_id);
          } else if (file.source) {
            url.searchParams.set("source", file.source);
          } else if (file.key) {
            url.searchParams.set("key", file.key);
          } else {
            throw new Error("Missing file identity");
          }
          const data = await apiRequest(url.pathname + url.search);
          state.browser.chunkDetails[cacheKey] = { loading: false, data };
        } catch (error) {
          state.browser.chunkDetails[cacheKey] = { loading: false, error: String(error.message || error) };
        }
        browserUpdateVisibleRowsByCacheKey(cacheKey);
      }

      async function browserLoadPartitionChunks(file, partitionIndex) {
        if (!state.activeBucketId) return;
        const fileKey = browserDetailsCacheKey(file);
        const cacheKey = browserPartitionChunkCacheKey(file, partitionIndex);
        const cache = state.browser.partitionChunks[cacheKey];
        if (cache && (cache.loading || cache.data || cache.error)) return;

        state.browser.partitionChunks[cacheKey] = { loading: true };
        browserUpdatePartitionBodies(fileKey, partitionIndex);
        try {
          const url = new URL(
            `/api/dashboard/buckets/${encodeURIComponent(state.activeBucketId)}/files/partitions/${partitionIndex}/chunks`,
            window.location.origin
          );
          if (file.document_id) {
            url.searchParams.set("document_id", file.document_id);
          } else if (file.source) {
            url.searchParams.set("source", file.source);
          } else if (file.key) {
            url.searchParams.set("key", file.key);
          } else {
            throw new Error("Missing file identity");
          }
          const data = await apiRequest(url.pathname + url.search);
          state.browser.partitionChunks[cacheKey] = { loading: false, data };
        } catch (error) {
          state.browser.partitionChunks[cacheKey] = { loading: false, error: String(error.message || error) };
        }
        if (state.browser.openPartitions[cacheKey]) {
          browserUpdatePartitionBodies(fileKey, partitionIndex);
        }
      }

      function browserTogglePartition(event) {
        const details = event.currentTarget;
        const fileKey = details.getAttribute("data-file-key") || "";
        const partitionIndex = Number.parseInt(details.getAttribute("data-partition-index") || "", 10);
        if (!fileKey || !partitionIndex) return;
        const file = browserFindFileByCacheKey(fileKey);
        if (!file) return;
        const partitionKey = browserPartitionChunkCacheKey(file, partitionIndex);
        if (details.open) {
          state.browser.openPartitions[partitionKey] = true;
          browserLoadPartitionChunks(file, partitionIndex);
        } else {
          delete state.browser.openPartitions[partitionKey];
        }
      }

      function browserToggleDetails(index) {
        const file = state.browser.visibleFiles[index];
        const summary = document.getElementById(`browser-summary-${index}`);
        const details = document.getElementById(`browser-details-${index}`);
        const toggle = document.getElementById(`browser-toggle-${index}`);
        if (!summary || !details || !toggle || !file) return;
        const open = !details.classList.contains("open");
        details.classList.toggle("open", open);
        summary.classList.toggle("open", open);
        toggle.textContent = open ? "▾" : "▸";
        toggle.setAttribute("aria-expanded", open ? "true" : "false");
        const key = browserDetailsCacheKey(file);
        if (open) {
          state.browser.openDetails[key] = true;
          browserLoadChunkDetails(file);
        } else {
          delete state.browser.openDetails[key];
        }
      }

      function browserRenderRows() {
        const rows = document.getElementById("browserRows");
        const searchInput = document.getElementById("browserSearch");
        if (!rows || !searchInput) return;
        const query = String(searchInput.value || "").toLowerCase();
        const shown = state.browser.files.filter((file) => browserMatchesSearch(file, query)).slice().sort(browserCompareBySource);
        state.browser.visibleFiles = shown;
        if (!shown.length) {
          rows.innerHTML = `<tr><td colspan="3">No matching files.</td></tr>`;
          return;
        }

        rows.innerHTML = shown
          .map((file, index) => {
            const redisMissing =
              (file.redis_chunks === null || file.redis_chunks === undefined) &&
              (file.redis_partitions === null || file.redis_partitions === undefined);
            const rowStyle = redisMissing ? `style="border-left: 3px solid rgba(255, 209, 102, 0.55);"` : "";
            const open = !!state.browser.openDetails[browserDetailsCacheKey(file)];
            const rowClass = open ? "browser-summary-row open" : "browser-summary-row";
            const detailClass = open ? "browser-details-row open" : "browser-details-row";
            const chevron = open ? "▾" : "▸";
            const expanded = open ? "true" : "false";
            const sourceText = browserSourceLabel(file);
            const sourceHtml = file.original_file_url
              ? `<a class="search-result-path" href="${browserEscAttr(file.original_file_url)}" target="_blank" rel="noopener noreferrer" onclick="event.stopPropagation()">${browserEsc(sourceText)}</a>`
              : `<span class="search-result-path">${browserEsc(sourceText)}</span>`;

            return `
            <tr id="browser-summary-${index}" class="${rowClass}" ${rowStyle} onclick="browserToggleDetails(${index})">
              <td>
                <button id="browser-toggle-${index}" class="browser-expander" type="button" onclick="event.stopPropagation(); browserToggleDetails(${index});" aria-expanded="${expanded}" aria-label="Toggle metadata details">${chevron}</button>
                <span>${browserEsc(browserFileLabel(file))}</span>
                <div>${sourceHtml}</div>
              </td>
              <td class="browser-right browser-nowrap">${browserFmt(browserTopLevelPartitions(file))}</td>
              <td class="browser-right browser-nowrap">${browserFmt(browserTopLevelChunks(file))}</td>
            </tr>
            <tr id="browser-details-${index}" class="${detailClass}">
              <td colspan="3" class="browser-details-cell">${browserDetailSectionsHtml(file)}</td>
            </tr>
          `;
          })
          .join("");
      }

      function browserResetState() {
        state.browser.loading = false;
        state.browser.files = [];
        state.browser.visibleFiles = [];
        state.browser.offset = null;
        state.browser.truncated = false;
        state.browser.chunkDetails = {};
        state.browser.partitionChunks = {};
        state.browser.openDetails = {};
        state.browser.openPartitions = {};
        state.browser.lastFetch = null;
        state.browser.error = "";
      }

      function browserRenderControls() {
        const title = document.getElementById("browserTitle");
        const subtitle = document.getElementById("browserSubtitle");
        const reloadBtn = document.getElementById("browserReload");
        const loadMoreBtn = document.getElementById("browserLoadMore");
        const footerLeft = document.getElementById("browserFooterLeft");
        const footerRight = document.getElementById("browserFooterRight");
        if (!title || !subtitle || !reloadBtn || !loadMoreBtn || !footerLeft || !footerRight) return;

        if (!state.activeBucketId) {
          title.textContent = "Select a bucket";
          subtitle.textContent = "Choose a shared bucket to inspect Qdrant metadata.";
          footerLeft.textContent = "-";
          footerRight.textContent = "-";
          loadMoreBtn.disabled = true;
          reloadBtn.disabled = true;
          return;
        }

        title.textContent = `Bucket: ${state.activeBucketId}`;
        reloadBtn.disabled = state.browser.loading;
        loadMoreBtn.disabled = state.browser.loading || !state.browser.truncated || !state.browser.offset;
        if (state.browser.error) {
          subtitle.textContent = `Error: ${state.browser.error}`;
        } else if (state.browser.loading) {
          subtitle.textContent = "Loading...";
        } else if (state.browser.lastFetch) {
          subtitle.textContent = `${browserFmt(state.browser.lastFetch.count)} unique files (scanned ${browserFmt(
            state.browser.lastFetch.scanned_points
          )} points)`;
        } else {
          subtitle.textContent = "Load files from Qdrant for this bucket.";
        }
        footerLeft.textContent = state.browser.truncated
          ? `More available (next offset: ${state.browser.offset})`
          : "End of list";
        footerRight.textContent = `Showing ${state.browser.files.length} rows`;
      }

      async function browserLoadFiles({ reset }) {
        if (!state.activeBucketId) return;
        const limitInput = document.getElementById("browserLimit");
        const limit = Number.parseInt(String(limitInput?.value || "200"), 10);
        const offset = reset ? null : state.browser.offset;
        if (reset) {
          state.browser.offset = null;
          state.browser.truncated = false;
          state.browser.openDetails = {};
          state.browser.chunkDetails = {};
          state.browser.partitionChunks = {};
          state.browser.openPartitions = {};
        }

        state.browser.loading = true;
        state.browser.error = "";
        browserRenderControls();
        try {
          const url = new URL(
            `/api/dashboard/buckets/${encodeURIComponent(state.activeBucketId)}/files`,
            window.location.origin
          );
          url.searchParams.set("limit", String(Number.isFinite(limit) ? limit : 200));
          if (offset) {
            url.searchParams.set("offset", String(offset));
          }
          const data = await apiRequest(url.pathname + url.search);
          state.browser.offset = data.next_offset || null;
          state.browser.truncated = !!data.truncated;
          const newFiles = Array.isArray(data.files) ? data.files : [];
          if (reset) {
            state.browser.files = newFiles;
          } else {
            const merged = state.browser.files.slice();
            const seen = new Set(merged.map((file) => browserDetailsCacheKey(file)));
            for (const file of newFiles) {
              const key = browserDetailsCacheKey(file);
              if (seen.has(key)) continue;
              merged.push(file);
              seen.add(key);
            }
            state.browser.files = merged;
          }
          state.browser.lastFetch = data;
          browserSetRedisStatus(state.browser.files);
          browserRenderRows();
        } catch (error) {
          state.browser.error = String(error.message || error);
          state.browser.files = [];
          state.browser.visibleFiles = [];
          const rows = document.getElementById("browserRows");
          if (rows) {
            rows.innerHTML = `<tr><td colspan="3">Failed to load files.</td></tr>`;
          }
        } finally {
          state.browser.loading = false;
          browserRenderControls();
        }
      }

      function browserRenderWorkspace() {
        browserRenderControls();
        browserSetRedisStatus(state.browser.files);
        browserRenderRows();
      }

      function safeSearchText(value) {
        if (value === undefined || value === null) return "";
        return String(value);
      }

      function searchTruncate(text, maxLen = 6000) {
        const raw = safeSearchText(text).trim();
        if (!raw) return "";
        if (raw.length <= maxLen) return raw;
        return `${raw.slice(0, maxLen - 3)}...`;
      }

      function searchSourcePath(item) {
        if (item && item.bucket && item.key) return `${item.bucket}/${item.key}`;
        if (item && item.source) return safeSearchText(item.source);
        if (item && item.document_id) return `document:${item.document_id}`;
        return "unknown source";
      }

      function searchPrettyJson(value) {
        try {
          return JSON.stringify(value, null, 2);
        } catch (_err) {
          return safeSearchText(value);
        }
      }

      function searchKeyRef(payload) {
        if (!payload || typeof payload !== "object") return "-";
        if (payload.bucket && payload.key) return `${safeSearchText(payload.bucket)}/${safeSearchText(payload.key)}`;
        if (payload.source) return safeSearchText(payload.source);
        return "-";
      }

      function searchExtractChunkText(entry) {
        if (!entry || typeof entry !== "object") return "";
        for (const key of ["text", "chunk_text", "content", "chunk", "page_content", "raw_text"]) {
          const value = entry[key];
          if (typeof value === "string" && value.trim()) {
            return value.trim();
          }
        }
        return "";
      }

      function searchFormatChunkTexts(chunks) {
        if (!Array.isArray(chunks) || chunks.length === 0) return "";
        const texts = [];
        for (const chunk of chunks) {
          const text = searchExtractChunkText(chunk);
          if (text) texts.push(text);
        }
        return texts.join("\n\n---\n\n");
      }

      function searchSetError(message) {
        state.search.error = safeSearchText(message);
      }

      function searchSelectedCollection() {
        const activeBucket = getActiveBucket();
        if (activeBucket && activeBucket.id) return safeSearchText(activeBucket.id);
        return "";
      }

      async function loadSearchStatus() {
        const payload = await apiRequest("/api/search/status");
        state.search.statusOk = Boolean(payload.ok);
        state.search.qdrantUrl = safeSearchText(payload.qdrant_url || "");
      }

      async function ensureSearchWorkspaceLoaded(force = false) {
        if (state.search.loading) return;
        if (!force && state.search.initialized) return;
        state.search.loading = true;
        if (force) {
          state.search.error = "";
        }
        renderAll();
        try {
          await loadSearchStatus();
          state.search.initialized = true;
          state.search.error = "";
        } catch (error) {
          searchSetError(error.message || "Failed to initialize search workspace");
        } finally {
          state.search.loading = false;
          renderAll();
        }
      }

      async function runSearchQuery() {
        const collection = searchSelectedCollection();
        if (!collection) {
          searchSetError("Select a bucket first.");
          renderAll();
          return;
        }

        const queryInput = document.getElementById("searchQueryInput");
        const topKInput = document.getElementById("searchTopKInput");
        const prefetchKInput = document.getElementById("searchPrefetchKInput");
        const retrievalModeInput = document.getElementById("searchRetrievalModeInput");
        if (!queryInput || !topKInput || !prefetchKInput || !retrievalModeInput) return;

        const query = safeSearchText(queryInput.value).trim();
        if (!query) {
          searchSetError("Enter a search query.");
          renderAll();
          return;
        }

        const retrievalMode = safeSearchText(retrievalModeInput.value || "hybrid").toLowerCase();
        state.search.retrievalMode = retrievalMode === "cosine" ? "cosine" : "hybrid";
        const topK = Number.parseInt(safeSearchText(topKInput.value || "8"), 10);
        const body = {
          query,
          topK: Number.isFinite(topK) ? topK : 8,
          retrievalMode: state.search.retrievalMode,
          collection,
        };
        if (state.search.retrievalMode === "hybrid") {
          const prefetchK = Number.parseInt(safeSearchText(prefetchKInput.value || "60"), 10);
          body.prefetchK = Number.isFinite(prefetchK) ? prefetchK : 60;
        }

        state.search.loading = true;
        state.search.error = "";
        state.search.meta = "Running search...";
        renderAll();
        try {
          const payload = await apiRequest("/api/search", {
            method: "POST",
            body: JSON.stringify(body),
          });
          state.search.results = Array.isArray(payload.results) ? payload.results : [];
          state.search.activeCollection = safeSearchText(payload.collection || body.collection || "");
          state.search.retrievalMode = safeSearchText(payload.retrieval_mode || state.search.retrievalMode || "hybrid").toLowerCase();
          state.search.details = {};
          state.search.meta =
            `Mode: ${state.search.retrievalMode} | Collection: ${state.search.activeCollection || "-"} | ` +
            `Results: ${state.search.results.length} | Latency: ${safeSearchText(payload.latency_ms)}ms`;
        } catch (error) {
          searchSetError(error.message || "Search failed");
          state.search.results = [];
          state.search.meta = "Search failed.";
        } finally {
          state.search.loading = false;
          renderAll();
        }
      }

      function searchPrimaryPage(item) {
        const rawStart = Number.parseInt(safeSearchText(item && item.page_start), 10);
        if (Number.isFinite(rawStart) && rawStart > 0) return rawStart;
        const pages = Array.isArray(item && item.pages) ? item.pages : [];
        const pageValues = pages
          .map((entry) => Number.parseInt(safeSearchText(entry), 10))
          .filter((entry) => Number.isFinite(entry) && entry > 0);
        if (pageValues.length > 0) return pageValues[0];
        const rawEnd = Number.parseInt(safeSearchText(item && item.page_end), 10);
        if (Number.isFinite(rawEnd) && rawEnd > 0) return rawEnd;
        return null;
      }

      function searchHighlightText(item) {
        const text = searchExtractChunkText(item);
        if (!text) return "";
        const normalized = text
          .toLowerCase()
          .replace(/[^0-9a-z]+/g, " ")
          .replace(/\s+/g, " ")
          .trim();
        if (!normalized) return "";
        let words = normalized.split(" ").filter((entry) => entry.length >= 3);
        if (words.length === 0) {
          words = normalized.split(" ").filter((entry) => entry.length > 0);
        }
        if (words.length === 0) return "";
        return words.slice(0, 8).join(" ");
      }

      function searchCitationHref(item) {
        let citationUrl =
          safeSearchText(item && item.citation_url_match) ||
          safeSearchText(item && item.citation_url);
        if (!citationUrl) {
          const sourceRef = safeSearchText(item && item.source_ref);
          if (sourceRef) {
            citationUrl = `/r/doc?ref=${encodeURIComponent(sourceRef)}`;
          }
        }
        if (!citationUrl) return "";

        try {
          const parsed = new URL(citationUrl, window.location.origin);
          const page = searchPrimaryPage(item);
          const pageStart = Number.parseInt(safeSearchText(item && item.page_start), 10);
          const pageEnd = Number.parseInt(safeSearchText(item && item.page_end), 10);
          const highlight = searchHighlightText(item);
          if (Number.isFinite(pageStart) && pageStart > 0 && !parsed.searchParams.has("page_start")) {
            parsed.searchParams.set("page_start", String(pageStart));
          }
          if (Number.isFinite(pageEnd) && pageEnd > 0 && !parsed.searchParams.has("page_end")) {
            parsed.searchParams.set("page_end", String(pageEnd));
          }
          if (page && !parsed.searchParams.has("page_start") && !parsed.searchParams.has("page_end")) {
            parsed.searchParams.set("page", String(page));
          }
          if (highlight && !parsed.searchParams.has("highlight")) {
            parsed.searchParams.set("highlight", highlight);
          }
          return parsed.toString();
        } catch (_error) {
          return citationUrl;
        }
      }

      function setSearchResultDetail(pointId, kind, payload) {
        const key = safeSearchText(pointId);
        const current = state.search.details[key] || {};
        state.search.details[key] = { ...current, [kind]: payload };
      }

      function searchDetailTitle(kind, payload) {
        if (!payload || payload.found === false) return `${kind} not found`;
        if (kind === "chunk") {
          return `Chunk ${safeSearchText(payload.chunk_index) || "-"}`;
        }
        if (kind === "partition") {
          const partition = payload.partition || {};
          return `${safeSearchText(partition.label || "Partition")} | chunks ${Number(payload.count || 0)}`;
        }
        if (kind === "document") {
          return `Document chunks ${Number(payload.count || 0)}`;
        }
        if (kind === "bibtex") {
          return `citation_key: ${safeSearchText(payload.citation_key || "-")}`;
        }
        return kind;
      }

      function searchDetailBody(kind, payload) {
        if (!payload) return "";
        if (kind === "chunk") {
          return searchTruncate(payload.text || "", 6000) || searchPrettyJson(payload);
        }
        if (kind === "bibtex") {
          return searchTruncate(searchPrettyJson(payload.metadata || payload), 6000);
        }
        if (kind === "partition") {
          const partition = payload.partition || {};
          const header = [
            `point_id: ${safeSearchText(payload.id || "-")}`,
            `document_id: ${safeSearchText(payload.document_id || "-")}`,
            `object: ${searchKeyRef(payload)}`,
            `partition: ${safeSearchText(partition.label || "-")} (${safeSearchText(partition.page_start || "-")} - ${safeSearchText(partition.page_end || "-")})`,
            `chunk_count: ${Number(payload.count || 0)}`,
          ];
          const body = searchFormatChunkTexts(payload.chunks || []);
          if (!body) {
            header.push("", "(No partition text found.)");
            return searchTruncate(header.join("\n"), 6000);
          }
          return searchTruncate(`${header.join("\n")}\n\n${body}`, 6000);
        }
        if (kind === "document") {
          const docIds = Array.isArray(payload.document_ids) ? payload.document_ids.join(", ") : "";
          const header = [
            `point_id: ${safeSearchText(payload.id || "-")}`,
            `document_id: ${safeSearchText(payload.document_id || docIds || "-")}`,
            `object: ${searchKeyRef(payload)}`,
            `chunk_count: ${Number(payload.count || 0)}`,
          ];
          const body = searchFormatChunkTexts(payload.chunks || []);
          if (!body) {
            header.push("", "(No document text found.)");
            return searchTruncate(header.join("\n"), 6000);
          }
          return searchTruncate(`${header.join("\n")}\n\n${body}`, 6000);
        }
        return searchTruncate(searchPrettyJson(payload), 6000);
      }

      function renderSearchDetailBox(kind, payload) {
        const wrapper = document.createElement("div");
        wrapper.className = "search-fetch-box";

        const label = document.createElement("div");
        label.className = "search-fetch-label";
        label.textContent = kind;

        const title = document.createElement("div");
        title.className = "search-fetch-title";
        title.textContent = searchDetailTitle(kind, payload);

        const text = document.createElement("pre");
        text.className = "search-fetch-text";
        text.textContent = searchDetailBody(kind, payload);

        wrapper.append(label, title, text);
        return wrapper;
      }

      function renderSearchDetails(pointId, card) {
        const detail = state.search.details[safeSearchText(pointId)];
        if (!detail) return;
        for (const kind of ["bibtex"]) {
          if (detail[kind] !== undefined) {
            card.appendChild(renderSearchDetailBox(kind, detail[kind]));
          }
        }
      }

      async function fetchSearchResultDetail(item, kind) {
        const pointId = safeSearchText(item && item.id);
        if (!pointId) return;
        const collection = state.search.activeCollection || searchSelectedCollection();
        const query = collection ? `?collection=${encodeURIComponent(collection)}` : "";
        const endpoint = {
          bibtex: `/api/search/chunk/${encodeURIComponent(pointId)}/bibtex`,
        }[kind];
        if (!endpoint) return;

        searchSetError("");
        renderAll();
        try {
          const payload = await apiRequest(`${endpoint}${query}`);
          setSearchResultDetail(pointId, kind, payload);
        } catch (error) {
          searchSetError(error.message || `Failed to fetch ${kind}`);
        } finally {
          renderAll();
        }
      }

      function renderSearchResults() {
        const resultsEl = document.getElementById("searchResults");
        const emptyEl = document.getElementById("searchEmptyState");
        if (!resultsEl || !emptyEl) return;
        resultsEl.innerHTML = "";

        const items = state.search.results || [];
        emptyEl.hidden = items.length > 0;
        for (const item of items) {
          const card = document.createElement("article");
          card.className = "search-result-card";

          const head = document.createElement("div");
          head.className = "search-result-head";

          const idText = document.createElement("strong");
          idText.className = "search-result-id";
          idText.textContent = `id: ${safeSearchText(item.id)}`;

          const score = document.createElement("span");
          score.className = "search-score";
          score.textContent = `score ${Number(item.score || 0).toFixed(4)}`;

          head.append(idText, score);

          const path = document.createElement("div");
          path.className = "search-result-path";
          path.textContent = searchSourcePath(item);

          const citationKey = document.createElement("div");
          citationKey.className = "search-result-path";
          citationKey.textContent = `citation_key: ${safeSearchText(item.citation_key || "-")}`;

          const snippet = document.createElement("p");
          snippet.className = "search-result-snippet";
          snippet.textContent = searchTruncate(item.text, 460) || "No text in payload.";

          const actions = document.createElement("div");
          actions.className = "search-actions";

          const fetchBibtexBtn = document.createElement("button");
          fetchBibtexBtn.type = "button";
          fetchBibtexBtn.className = "bulk-btn";
          fetchBibtexBtn.textContent = "Show BibTeX";
          fetchBibtexBtn.addEventListener("click", () => {
            fetchSearchResultDetail(item, "bibtex");
          });
          actions.append(fetchBibtexBtn);

          const citationHref = searchCitationHref(item);
          if (citationHref) {
            const openLink = document.createElement("a");
            openLink.className = "bulk-btn";
            openLink.href = citationHref;
            openLink.target = "_blank";
            openLink.rel = "noopener noreferrer";
            openLink.textContent = "Open Citation";
            actions.append(openLink);
          }

          card.append(head, path, citationKey, snippet, actions);
          renderSearchDetails(item.id, card);
          resultsEl.append(card);
        }
      }

      function renderSearchWorkspace() {
        const queryInput = document.getElementById("searchQueryInput");
        const topKInput = document.getElementById("searchTopKInput");
        const prefetchKInput = document.getElementById("searchPrefetchKInput");
        const prefetchField = document.getElementById("searchPrefetchField");
        const retrievalModeInput = document.getElementById("searchRetrievalModeInput");
        const runBtn = document.getElementById("searchRunBtn");
        const refreshBtn = document.getElementById("searchRefreshBtn");
        const statusLine = document.getElementById("searchStatusLine");
        const meta = document.getElementById("searchMeta");
        const error = document.getElementById("searchError");
        if (
          !queryInput ||
          !topKInput ||
          !prefetchKInput ||
          !prefetchField ||
          !retrievalModeInput ||
          !runBtn ||
          !refreshBtn ||
          !statusLine ||
          !meta ||
          !error
        ) {
          return;
        }

        retrievalModeInput.value = state.search.retrievalMode === "cosine" ? "cosine" : "hybrid";
        prefetchField.hidden = state.search.retrievalMode === "cosine";

        const busy = state.search.loading;
        const selectedCollection = searchSelectedCollection();
        runBtn.disabled = busy || !state.search.initialized || !selectedCollection;
        runBtn.textContent = busy ? "Searching..." : "Search";
        refreshBtn.disabled = busy;
        retrievalModeInput.disabled = busy;
        topKInput.disabled = busy;
        prefetchKInput.disabled = busy || state.search.retrievalMode === "cosine";
        queryInput.disabled = busy;

        const statusParts = [];
        statusParts.push(state.search.statusOk ? "Connected" : "Unavailable");
        if (state.search.qdrantUrl) {
          statusParts.push(state.search.qdrantUrl);
        }
        statusParts.push(`collection: ${selectedCollection || "(select a bucket)"}`);
        statusLine.textContent = `Status: ${statusParts.join(" | ")}`;
        meta.textContent = state.search.meta || "Run a search to see results.";
        error.textContent = state.search.error || "";

        renderSearchResults();
      }

      function sortValueForFile(file, key) {
        if (key === "authors") {
          return formatAuthorsApa(coerceAuthors(file));
        }
        if (key === "title") {
          return displayTitle(file);
        }
        if (key === "source") {
          return displaySource(file);
        }
        const value = file[key];
        return value == null ? "" : String(value);
      }

      function compareSortValues(left, right, key) {
        if (key === "year") {
          const leftNum = Number.parseInt(left, 10);
          const rightNum = Number.parseInt(right, 10);
          const leftIsNum = Number.isFinite(leftNum);
          const rightIsNum = Number.isFinite(rightNum);
          if (leftIsNum && rightIsNum) {
            return leftNum - rightNum;
          }
          if (leftIsNum) return -1;
          if (rightIsNum) return 1;
        }
        return left.localeCompare(right, undefined, { numeric: true, sensitivity: "base" });
      }

      function sortFiles(files) {
        const { key, direction } = state.sort;
        const sorted = [...files].sort((leftFile, rightFile) => {
          const left = sortValueForFile(leftFile, key);
          const right = sortValueForFile(rightFile, key);
          let result = compareSortValues(left, right, key);
          if (result === 0) {
            result = sortValueForFile(leftFile, "fileName").localeCompare(
              sortValueForFile(rightFile, "fileName"),
              undefined,
              { numeric: true, sensitivity: "base" }
            );
          }
          return direction === "asc" ? result : -result;
        });
        return sorted;
      }

      function updateSortIndicators() {
        const buttons = document.querySelectorAll(".sort-btn");
        for (const button of buttons) {
          const key = button.dataset.sortKey;
          const active = key === state.sort.key;
          button.classList.toggle("active", active);
          const indicator = button.querySelector(".sort-indicator");
          if (!indicator) continue;
          indicator.textContent = active ? (state.sort.direction === "asc" ? "▲" : "▼") : "↕";
        }
      }

      function setSort(key) {
        if (state.sort.key === key) {
          state.sort.direction = state.sort.direction === "asc" ? "desc" : "asc";
        } else {
          state.sort.key = key;
          state.sort.direction = "asc";
        }
        renderAll();
      }

      function initSortControls() {
        const buttons = document.querySelectorAll(".sort-btn");
        for (const button of buttons) {
          button.addEventListener("click", () => {
            setSort(button.dataset.sortKey);
          });
        }
      }

      function initViewToggleControls() {
        const bulkBtn = document.getElementById("viewToggleBulk");
        const detailBtn = document.getElementById("viewToggleDetail");
        if (bulkBtn) {
          bulkBtn.addEventListener("click", () => setViewMode("bulk"));
        }
        if (detailBtn) {
          detailBtn.addEventListener("click", () => setViewMode("detail"));
        }
      }

      function initWorkspaceTabs() {
        const browserBtn = document.getElementById("workspaceTabBrowser");
        const bibtexBtn = document.getElementById("workspaceTabBibtex");
        const searchBtn = document.getElementById("workspaceTabSearch");
        if (browserBtn) {
          browserBtn.addEventListener("click", () => {
            setWorkspaceTab("browser");
          });
        }
        if (bibtexBtn) {
          bibtexBtn.addEventListener("click", () => {
            setWorkspaceTab("bibtex");
          });
        }
        if (searchBtn) {
          searchBtn.addEventListener("click", () => {
            setWorkspaceTab("search");
          });
        }
      }

      function renderAutofillControls() {
        const button = document.getElementById("autofillMissingBtn");
        const status = document.getElementById("autofillStatus");
        const progressWrap = document.getElementById("autofillProgress");
        const progressFill = document.getElementById("autofillProgressFill");
        const progressText = document.getElementById("autofillProgressText");
        if (!button || !status || !progressWrap || !progressFill || !progressText) return;

        const activeBucket = getActiveBucket();
        const ready = !!activeBucket && activeBucket.loaded && !activeBucket.loading;
        button.disabled = !ready || state.autofill.running;
        button.textContent = state.autofill.running ? "Autofilling..." : "Autofill Missing Metadata";
        status.textContent = state.autofill.message || "Ready.";

        const total = Number(state.autofill.total || 0);
        const processed = Number(state.autofill.processed || 0);
        const hasProgress = total > 0 || state.autofill.running;
        progressWrap.hidden = !hasProgress;
        if (!hasProgress) {
          progressFill.style.width = "0%";
          progressText.textContent = "";
          return;
        }

        const percent = total > 0 ? Math.min(100, Math.round((processed / total) * 100)) : 0;
        progressFill.style.width = `${percent}%`;
        const updated = Number(state.autofill.counts.updated || 0);
        const skipped = Number(state.autofill.counts.skipped_existing || 0);
        const lowConfidence = Number(state.autofill.counts.low_confidence || 0);
        const conflicts = Number(state.autofill.counts.doi_conflict || 0);
        const failed = Number(state.autofill.counts.error || 0);
        progressText.textContent =
          `${processed}/${total} • ${percent}% • updated ${updated} • skipped ${skipped} • low confidence ${lowConfidence} • DOI conflicts ${conflicts} • errors ${failed}`;
      }

      function renderBucketManagerControls() {
        const addBtn = document.getElementById("openAddBucketModalBtn");
        const delBtn = document.getElementById("openDeleteBucketModalBtn");
        const status = document.getElementById("bucketManagerStatus");
        const addConfirmBtn = document.getElementById("addBucketConfirmBtn");
        const deleteConfirmBtn = document.getElementById("deleteBucketConfirmBtn");
        const addCancelBtn = document.getElementById("addBucketModalCancel");
        const deleteCancelBtn = document.getElementById("deleteBucketModalCancel");
        const addCloseBtn = document.getElementById("addBucketModalClose");
        const deleteCloseBtn = document.getElementById("deleteBucketModalClose");
        if (!addBtn || !delBtn || !status) return;

        const activeBucket = getActiveBucket();
        const busy = state.bucketOps.running || state.loadingBuckets;
        addBtn.disabled = busy;
        delBtn.disabled = busy || !activeBucket;
        if (addConfirmBtn) {
          addConfirmBtn.disabled = busy;
          addConfirmBtn.textContent = state.bucketOps.running ? "Creating..." : "Create Bucket";
        }
        if (deleteConfirmBtn) {
          deleteConfirmBtn.disabled = busy;
          deleteConfirmBtn.textContent = state.bucketOps.running ? "Deleting..." : "Delete Bucket";
        }
        if (addCancelBtn) addCancelBtn.disabled = busy;
        if (deleteCancelBtn) deleteCancelBtn.disabled = busy;
        if (addCloseBtn) addCloseBtn.disabled = busy;
        if (deleteCloseBtn) deleteCloseBtn.disabled = busy;
        status.textContent = state.bucketOps.message || "Ready.";
      }

      function renderUploadControls() {
        const button = document.getElementById("openUploadModalBtn");
        const modal = document.getElementById("uploadModal");
        const filesInput = document.getElementById("uploadModalFilesInput");
        const submitBtn = document.getElementById("uploadModalSubmit");
        const cancelBtn = document.getElementById("uploadModalCancel");
        const closeBtn = document.getElementById("uploadModalClose");
        const status = document.getElementById("uploadStatus");
        const progressWrap = document.getElementById("uploadProgress");
        const progressFill = document.getElementById("uploadProgressFill");
        const progressText = document.getElementById("uploadProgressText");
        if (!button || !status || !progressWrap || !progressFill || !progressText) {
          return;
        }

        const activeBucket = getActiveBucket();
        const bucketReady = !!activeBucket && activeBucket.loaded && !activeBucket.loading;
        const disabled = !bucketReady || state.upload.running;
        button.disabled = disabled;
        button.textContent = state.upload.running ? "Uploading..." : "Upload PDF";
        if (filesInput) filesInput.disabled = state.upload.running || !bucketReady;
        if (submitBtn) {
          submitBtn.disabled = state.upload.running || !bucketReady;
          submitBtn.textContent = state.upload.running ? "Uploading..." : "Upload";
        }
        if (cancelBtn) cancelBtn.disabled = state.upload.running;
        if (closeBtn) closeBtn.disabled = state.upload.running;
        status.textContent = state.upload.message || "";
        status.hidden = !state.upload.message;
        if (!bucketReady && modal && !modal.hidden && !state.upload.running) {
          modal.hidden = true;
        }

        const hasProgress =
          state.upload.running ||
          state.upload.phase === "queued" ||
          state.upload.phase === "completed" ||
          state.upload.phase === "failed";
        progressWrap.hidden = !hasProgress;
        if (!hasProgress) {
          progressFill.style.width = "0%";
          progressText.textContent = "";
          return;
        }
        const percent = Math.max(0, Math.min(100, Math.round(Number(state.upload.progress || 0))));
        progressFill.style.width = `${percent}%`;
        const phase = String(state.upload.phase || "idle");
        const error = state.upload.error ? ` • error ${state.upload.error}` : "";
        progressText.textContent = `${percent}% • ${phase}${error}`;
      }

      function initAutofillControls() {
        const button = document.getElementById("autofillMissingBtn");
        if (!button) return;
        button.addEventListener("click", () => {
          runAutofillMissing();
        });
      }

      function initBucketManagerControls() {
        const addBtn = document.getElementById("openAddBucketModalBtn");
        const delBtn = document.getElementById("openDeleteBucketModalBtn");
        const addConfirmBtn = document.getElementById("addBucketConfirmBtn");
        const addCancelBtn = document.getElementById("addBucketModalCancel");
        const addCloseBtn = document.getElementById("addBucketModalClose");
        const addInput = document.getElementById("addBucketModalInput");
        const addModal = document.getElementById("addBucketModal");
        const deleteConfirmBtn = document.getElementById("deleteBucketConfirmBtn");
        const deleteCancelBtn = document.getElementById("deleteBucketModalCancel");
        const deleteCloseBtn = document.getElementById("deleteBucketModalClose");
        const deleteModal = document.getElementById("deleteBucketModal");

        if (addBtn) {
          addBtn.addEventListener("click", () => {
            openAddBucketModal();
          });
        }
        if (delBtn) {
          delBtn.addEventListener("click", () => {
            openDeleteBucketModal();
          });
        }
        if (addConfirmBtn) {
          addConfirmBtn.addEventListener("click", () => {
            confirmAddBucketFromModal();
          });
        }
        if (addCancelBtn) {
          addCancelBtn.addEventListener("click", () => {
            closeAddBucketModal();
          });
        }
        if (addCloseBtn) {
          addCloseBtn.addEventListener("click", () => {
            closeAddBucketModal();
          });
        }
        if (addInput) {
          addInput.addEventListener("keydown", (event) => {
            if (event.key !== "Enter") return;
            event.preventDefault();
            confirmAddBucketFromModal();
          });
        }
        if (addModal) {
          addModal.addEventListener("click", (event) => {
            if (event.target === addModal && !state.bucketOps.running) {
              closeAddBucketModal();
            }
          });
        }
        if (deleteConfirmBtn) {
          deleteConfirmBtn.addEventListener("click", () => {
            confirmDeleteBucketFromModal();
          });
        }
        if (deleteCancelBtn) {
          deleteCancelBtn.addEventListener("click", () => {
            closeDeleteBucketModal();
          });
        }
        if (deleteCloseBtn) {
          deleteCloseBtn.addEventListener("click", () => {
            closeDeleteBucketModal();
          });
        }
        if (deleteModal) {
          deleteModal.addEventListener("click", (event) => {
            if (event.target === deleteModal && !state.bucketOps.running) {
              closeDeleteBucketModal();
            }
          });
        }
      }

      function initUploadControls() {
        const openBtn = document.getElementById("openUploadModalBtn");
        const modal = document.getElementById("uploadModal");
        const closeBtn = document.getElementById("uploadModalClose");
        const cancelBtn = document.getElementById("uploadModalCancel");
        const submitBtn = document.getElementById("uploadModalSubmit");
        const filesInput = document.getElementById("uploadModalFilesInput");
        if (openBtn) {
          openBtn.addEventListener("click", () => {
            openUploadModal();
          });
        }
        if (closeBtn) {
          closeBtn.addEventListener("click", () => {
            closeUploadModal();
          });
        }
        if (cancelBtn) {
          cancelBtn.addEventListener("click", () => {
            closeUploadModal();
          });
        }
        if (submitBtn) {
          submitBtn.addEventListener("click", () => {
            uploadFileToActiveBucket();
          });
        }
        if (filesInput) {
          filesInput.addEventListener("keydown", (event) => {
            if (event.key !== "Enter") return;
            event.preventDefault();
            uploadFileToActiveBucket();
          });
        }
        if (modal) {
          modal.addEventListener("click", (event) => {
            if (event.target === modal && !state.upload.running) {
              closeUploadModal();
            }
          });
        }
      }

      function initSearchControls() {
        const form = document.getElementById("searchForm");
        const runBtn = document.getElementById("searchRunBtn");
        const refreshBtn = document.getElementById("searchRefreshBtn");
        const retrievalModeInput = document.getElementById("searchRetrievalModeInput");

        if (form) {
          form.addEventListener("submit", (event) => {
            event.preventDefault();
            runSearchQuery();
          });
        }
        if (runBtn) {
          runBtn.addEventListener("click", (event) => {
            event.preventDefault();
            runSearchQuery();
          });
        }
        if (refreshBtn) {
          refreshBtn.addEventListener("click", () => {
            ensureSearchWorkspaceLoaded(true);
          });
        }
        if (retrievalModeInput) {
          retrievalModeInput.addEventListener("change", () => {
            const mode = safeSearchText(retrievalModeInput.value || "hybrid").toLowerCase();
            state.search.retrievalMode = mode === "cosine" ? "cosine" : "hybrid";
            renderAll();
          });
        }
      }

      function initBrowserControls() {
        const searchInput = document.getElementById("browserSearch");
        const reloadBtn = document.getElementById("browserReload");
        const loadMoreBtn = document.getElementById("browserLoadMore");
        if (searchInput) {
          searchInput.addEventListener("input", () => {
            browserRenderRows();
          });
        }
        if (reloadBtn) {
          reloadBtn.addEventListener("click", () => {
            browserLoadFiles({ reset: true });
          });
        }
        if (loadMoreBtn) {
          loadMoreBtn.addEventListener("click", () => {
            browserLoadFiles({ reset: false });
          });
        }
      }

      function initBulkControls() {
        const copyBtn = document.getElementById("bulkCopyBtn");
        const saveBtn = document.getElementById("bulkSaveBtn");
        if (copyBtn) {
          copyBtn.addEventListener("click", () => {
            copyBulkTsv();
          });
        }
        if (saveBtn) {
          saveBtn.addEventListener("click", () => {
            saveBulkChanges();
          });
        }
      }

      function redisSummaryForFile(file) {
        if (!file) return null;
        return state.redisSummaryByFile[file.id] || null;
      }

      async function ensureRedisSummary(file) {
        if (!file || !file.bucket || !file.objectName) return;
        const existing = redisSummaryForFile(file);
        if (existing && (existing.status === "loading" || existing.status === "loaded")) {
          return;
        }

        state.redisSummaryByFile[file.id] = {
          status: "loading",
          partitionCount: 0,
          docIds: [],
          sourcePrefix: "",
          error: "",
        };

        try {
          const data = await apiRequest(
            `/api/buckets/${encodeURIComponent(file.bucket)}/files/${encodeObjectPath(file.objectName)}/redis-summary`
          );
          state.redisSummaryByFile[file.id] = {
            status: "loaded",
            partitionCount: Number(data.partition_count || 0),
            docIds: Array.isArray(data.doc_ids) ? data.doc_ids : [],
            sourcePrefix: String(data.source_prefix || ""),
            error: "",
          };
        } catch (error) {
          state.redisSummaryByFile[file.id] = {
            status: "error",
            partitionCount: 0,
            docIds: [],
            sourcePrefix: "",
            error: String(error.message || error),
          };
        }
        renderAll();
      }

      function modalCacheKey(file) {
        return file.id;
      }

      async function openRedisModal(file) {
        if (!file || !file.bucket || !file.objectName) return;

        state.modal.open = true;
        state.modal.fileId = file.id;
        state.modal.loading = true;
        state.modal.error = "";
        state.modal.items = [];
        state.modal.totalAvailable = 0;
        renderModal();

        const cacheKey = modalCacheKey(file);
        if (state.redisDetailCache[cacheKey]) {
          const cached = state.redisDetailCache[cacheKey];
          state.modal.loading = false;
          state.modal.error = "";
          state.modal.items = cached.items || [];
          state.modal.totalAvailable = Number(cached.totalAvailable || 0);
          renderModal();
          return;
        }

        try {
          const data = await apiRequest(
            `/api/buckets/${encodeURIComponent(file.bucket)}/files/${encodeObjectPath(file.objectName)}/redis-data?kind=partitions&limit=250`
          );
          const payload = {
            items: Array.isArray(data.items) ? data.items : [],
            totalAvailable: Number(data.total_available || 0),
          };
          state.redisDetailCache[cacheKey] = payload;
          state.modal.loading = false;
          state.modal.error = "";
          state.modal.items = payload.items;
          state.modal.totalAvailable = payload.totalAvailable;
        } catch (error) {
          state.modal.loading = false;
          state.modal.error = String(error.message || error);
          state.modal.items = [];
          state.modal.totalAvailable = 0;
        }
        renderModal();
      }

      function closeDataModal() {
        state.modal.open = false;
        state.modal.loading = false;
        state.modal.error = "";
        state.modal.items = [];
        state.modal.totalAvailable = 0;
        renderModal();
      }

      function renderModal() {
        const modal = document.getElementById("dataModal");
        const modalTitle = document.getElementById("dataModalTitle");
        const modalBody = document.getElementById("dataModalBody");
        if (!modal || !modalTitle || !modalBody) return;

        if (!state.modal.open) {
          modal.hidden = true;
          modalBody.innerHTML = "";
          return;
        }

        const file = findFileById(state.modal.fileId) || getActiveFile();
        const fileLabel = file ? file.fileName : "File";
        modalTitle.textContent = `Partition Markdown - ${fileLabel}`;
        modal.hidden = false;
        modalBody.innerHTML = "";

        const note = document.createElement("div");
        note.className = "modal-note";
        modalBody.append(note);

        if (state.modal.loading) {
          note.textContent = "Loading Redis data...";
          return;
        }

        if (state.modal.error) {
          note.textContent = `Error: ${state.modal.error}`;
          return;
        }

        const loadedCount = state.modal.items.length;
        note.textContent = `Loaded ${loadedCount} item(s)` +
          (state.modal.totalAvailable > loadedCount ? ` of ${state.modal.totalAvailable} (lazy loaded)` : "") +
          ".";

        if (loadedCount === 0) {
          const empty = document.createElement("div");
          empty.className = "modal-note";
          empty.textContent = "No text entries found for this file.";
          modalBody.append(empty);
          return;
        }

        for (const item of state.modal.items) {
          const wrap = document.createElement("div");
          wrap.className = "modal-item";

          const label = document.createElement("div");
          label.className = "modal-item-label";
          label.textContent = item.label || "Entry";

          const text = document.createElement("pre");
          text.className = "modal-item-text";
          text.textContent = item.text || "";

          wrap.append(label, text);
          modalBody.append(wrap);
        }
      }

      function initModalControls() {
        const modal = document.getElementById("dataModal");
        const closeBtn = document.getElementById("dataModalClose");
        if (closeBtn) {
          closeBtn.addEventListener("click", closeDataModal);
        }
        if (modal) {
          modal.addEventListener("click", (event) => {
            if (event.target === modal) {
              closeDataModal();
            }
          });
        }
      }

      async function loadBuckets() {
        state.loadingBuckets = true;
        state.bucketsError = "";
        renderAll();
        try {
          const data = await apiRequest("/api/buckets");
          const names = Array.isArray(data.buckets) ? data.buckets : [];
          state.buckets = names.map((name) => ({
            id: name,
            name,
            files: [],
            loaded: false,
            loading: false,
            error: "",
          }));
          const hasActiveSelection = state.buckets.some((bucket) => bucket.id === state.activeBucketId);
          if (!hasActiveSelection) {
            const persistedBucketId = readSelectedBucketCookie();
            const hasPersistedSelection = state.buckets.some((bucket) => bucket.id === persistedBucketId);
            state.activeBucketId = hasPersistedSelection
              ? persistedBucketId
              : state.buckets.length > 0
                ? state.buckets[0].id
                : null;
            state.activeFileId = null;
          }
          browserResetState();
          writeSelectedBucketCookie(state.activeBucketId);
          renderAll();
          if (state.buckets.length > 0) {
            await Promise.allSettled(state.buckets.map((bucket) => ensureBucketLoaded(bucket.id)));
          }
          if (state.workspaceTab === "browser" && state.activeBucketId) {
            await browserLoadFiles({ reset: true });
          }
        } catch (error) {
          state.buckets = [];
          state.activeBucketId = null;
          state.activeFileId = null;
          state.bucketsError = String(error.message || error);
          renderAll();
        } finally {
          state.loadingBuckets = false;
          renderBuckets();
        }
      }

      async function ensureBucketLoaded(bucketId) {
        const bucket = bucketById(bucketId);
        if (!bucket || bucket.loaded || bucket.loading) {
          return;
        }
        bucket.loading = true;
        bucket.error = "";
        renderAll();
        try {
          const data = await apiRequest(`/api/buckets/${encodeURIComponent(bucketId)}/files`);
          const files = Array.isArray(data.files) ? data.files : [];
          bucket.files = files.map(normalizeFileRecord);
          bucket.loaded = true;
          if (state.activeBucketId === bucketId) {
            const hasActive = bucket.files.some((file) => file.id === state.activeFileId);
            if (!hasActive) {
              state.activeFileId = bucket.files.length > 0 ? bucket.files[0].id : null;
            }
          }
        } catch (error) {
          bucket.loaded = true;
          bucket.files = [];
          bucket.error = String(error.message || error);
          if (state.activeBucketId === bucketId) {
            state.activeFileId = null;
          }
        } finally {
          bucket.loading = false;
          renderAll();
        }
      }

      function selectBucket(bucketId) {
        state.activeBucketId = bucketId;
        state.activeFileId = null;
        browserResetState();
        writeSelectedBucketCookie(bucketId);
        if (!state.autofill.running) {
          resetAutofillState();
        }
        updateBulkStatusText();
        renderAll();
        ensureBucketLoaded(bucketId);
        if (state.workspaceTab === "browser") {
          browserLoadFiles({ reset: true });
        }
      }

      function selectFile(fileId) {
        state.activeFileId = fileId;
        renderAll();
      }

      function buildSavePayload(file) {
        const payload = {};
        for (const key of persistFieldKeys) {
          if (key === "authors") {
            payload[key] = coerceAuthors(file);
          } else {
            payload[key] = file[key] == null ? "" : file[key];
          }
        }
        return payload;
      }

      async function persistFileMetadata(file) {
        const data = await apiRequest(
          `/api/buckets/${encodeURIComponent(file.bucket)}/files/${encodeObjectPath(file.objectName)}/bibtex`,
          {
            method: "PUT",
            body: JSON.stringify(buildSavePayload(file)),
          }
        );
        return normalizeFileRecord(data.file || {});
      }

      async function saveFile(file) {
        if (!file || !file.bucket || !file.objectName) {
          return;
        }
        const priorSave = saveInFlightByFileId.get(file.id);
        if (priorSave) {
          try {
            await priorSave;
          } catch (_error) {
            // Continue and allow the latest save attempt.
          }
        }

        const savePromise = (async () => {
          state.saveState = "saving";
          state.saveFileId = file.id;
          state.saveError = "";
          renderTable();
          try {
            const saved = await persistFileMetadata(file);
            Object.assign(file, saved);
            state.saveState = "saved";
            state.saveFileId = file.id;
            state.saveError = "";
          } catch (error) {
            state.saveState = "error";
            state.saveFileId = file.id;
            state.saveError = String(error.message || error);
          }
          renderAll();
        })();

        saveInFlightByFileId.set(file.id, savePromise);
        try {
          await savePromise;
        } finally {
          if (saveInFlightByFileId.get(file.id) === savePromise) {
            saveInFlightByFileId.delete(file.id);
          }
        }
      }

      async function lookupByDoiForFile(file) {
        if (!file || !file.bucket || !file.objectName || state.doiLookup.running) return;
        const doi = String(file.doi || "").trim();
        if (!doi) return;

        const confirmed = window.confirm(
          "DOI lookup will overwrite existing metadata for this file with CrossRef values. Continue?"
        );
        if (!confirmed) return;

        cancelScheduledSave(file.id);
        const pendingSave = saveInFlightByFileId.get(file.id);
        if (pendingSave) {
          try {
            await pendingSave;
          } catch (_error) {
            // Lookup can still proceed even if a prior autosave failed.
          }
        }
        state.doiLookup.running = true;
        state.doiLookup.fileId = file.id;
        state.doiLookup.message = "Looking up DOI via CrossRef...";
        state.doiLookup.error = "";
        renderEditor();

        try {
          const data = await apiRequest(
            `/api/buckets/${encodeURIComponent(file.bucket)}/files/${encodeObjectPath(file.objectName)}/lookup-by-doi`,
            {
              method: "POST",
              body: JSON.stringify({ doi, overwrite: true }),
            }
          );
          const updated = normalizeFileRecord(data.file || {});
          Object.assign(file, updated);
          state.doiLookup.running = false;
          state.doiLookup.fileId = file.id;
          state.doiLookup.error = "";
          state.doiLookup.message = "CrossRef metadata applied.";
          renderAll();
        } catch (error) {
          state.doiLookup.running = false;
          state.doiLookup.fileId = file.id;
          state.doiLookup.error = String(error.message || error);
          state.doiLookup.message = "";
          renderEditor();
        }
      }

      function applyBulkEditsToDraft(file, edits) {
        const draft = normalizeFileRecord({ ...file });
        for (const [key, value] of Object.entries(edits || {})) {
          if (key === "minioPath" || key === "redisDocId") continue;
          if (key === "authors") {
            draft.authors = parseBulkAuthors(value);
            continue;
          }
          if (key === "entryType") {
            const normalized = String(value || "").trim().toLowerCase();
            draft.entryType = isKnownEntryType(normalized) ? normalized : "article";
            continue;
          }
          draft[key] = String(value ?? "");
        }
        return draft;
      }

      async function saveBulkChanges() {
        finalizeBulkEditing();
        const pendingEntries = Object.entries(state.bulk.edits);
        if (pendingEntries.length === 0) {
          state.bulk.status = "No pending changes.";
          state.bulk.error = "";
          renderBulkView();
          return;
        }

        state.bulk.saving = true;
        state.bulk.error = "";
        state.bulk.status = `Saving ${pendingEntries.length} file(s)...`;
        renderBulkView();

        let savedCount = 0;
        let failedCount = 0;
        for (const [fileId, edits] of pendingEntries) {
          const file = findFileById(fileId);
          if (!file) {
            delete state.bulk.edits[fileId];
            continue;
          }
          const draft = applyBulkEditsToDraft(file, edits);
          try {
            const saved = await persistFileMetadata(draft);
            Object.assign(file, saved);
            delete state.bulk.edits[fileId];
            savedCount += 1;
          } catch (error) {
            failedCount += 1;
            state.bulk.error = String(error.message || error);
          }
        }

        state.bulk.saving = false;
        if (failedCount > 0) {
          const remaining = Object.keys(state.bulk.edits).length;
          state.bulk.status = `Saved ${savedCount}; ${failedCount} failed. ${remaining} file(s) still pending.`;
        } else {
          state.bulk.status = `Saved ${savedCount} file(s).`;
          updateBulkStatusText();
        }
        renderAll();
      }

      async function copyBulkTsv() {
        finalizeBulkEditing();
        const files = bulkFilesForActiveBucket();
        if (files.length === 0) {
          state.bulk.status = "No rows to copy.";
          renderBulkView();
          return;
        }

        const lines = [];
        lines.push(bulkColumns.map((column) => column.label).join("\t"));
        for (const file of files) {
          const row = bulkColumns.map((column) => getBulkCellValue(file, column.key));
          lines.push(row.join("\t"));
        }
        const text = lines.join("\n");
        try {
          await navigator.clipboard.writeText(text);
          state.bulk.status = `Copied ${files.length} row(s) to clipboard.`;
          state.bulk.error = "";
        } catch (error) {
          state.bulk.status = "Clipboard copy failed.";
          state.bulk.error = String(error.message || error);
        }
        renderBulkView();
      }

      function cancelScheduledSave(fileId) {
        const existingTimer = saveTimers.get(fileId);
        if (!existingTimer) return;
        clearTimeout(existingTimer);
        saveTimers.delete(fileId);
      }

      function scheduleSave(file) {
        if (!file) return;
        state.saveState = "pending";
        state.saveFileId = file.id;
        state.saveError = "";
        renderTable();
        cancelScheduledSave(file.id);
        const timer = setTimeout(() => {
          saveTimers.delete(file.id);
          saveFile(file);
        }, 500);
        saveTimers.set(file.id, timer);
      }

      async function clearSelectedFileMetadata(file) {
        if (!file) return;
        const confirmed = window.confirm(`Clear metadata for "${file.fileName}"?`);
        if (!confirmed) return;

        cancelScheduledSave(file.id);
        for (const key of Object.keys(defaultFileFields)) {
          if (key === "authors") {
            file.authors = [];
            continue;
          }
          file[key] = defaultFileFields[key];
        }

        renderTable();
        renderEditor();
        await saveFile(file);
      }

      function renderBuckets() {
        const bucketList = document.getElementById("bucketList");
        bucketList.innerHTML = "";

        if (state.loadingBuckets && state.buckets.length === 0) {
          const loading = document.createElement("div");
          loading.className = "pane-subtitle";
          loading.textContent = "Loading buckets...";
          bucketList.append(loading);
          return;
        }

        if (state.bucketsError) {
          const error = document.createElement("div");
          error.className = "pane-subtitle";
          error.textContent = `Error: ${state.bucketsError}`;
          bucketList.append(error);
        }

        if (state.buckets.length === 0 && !state.bucketsError) {
          const empty = document.createElement("div");
          empty.className = "pane-subtitle";
          empty.textContent = "No buckets configured.";
          bucketList.append(empty);
          return;
        }

        for (const bucket of state.buckets) {
          const button = document.createElement("button");
          button.className = "bucket-btn" + (bucket.id === state.activeBucketId ? " active" : "");
          button.type = "button";
          button.addEventListener("click", () => selectBucket(bucket.id));

          const name = document.createElement("span");
          name.className = "bucket-name";
          name.textContent = bucket.name;

          const count = document.createElement("span");
          count.className = "bucket-count";
          count.textContent = bucket.loading ? "..." : String(bucket.files.length);

          button.append(name, count);
          bucketList.append(button);
        }
      }

      function selectionHintText(activeFile) {
        if (!activeFile) {
          return "Select a file to edit metadata";
        }
        let text = `Selected: ${activeFile.fileName}`;
        if (state.saveFileId === activeFile.id) {
          if (state.saveState === "pending") text += " • Save queued...";
          if (state.saveState === "saving") text += " • Saving to Redis...";
          if (state.saveState === "saved") text += " • Saved to Redis";
          if (state.saveState === "error") text += ` • Save failed: ${state.saveError}`;
        }
        return text;
      }

      function renderViewToggle() {
        const bulkBtn = document.getElementById("viewToggleBulk");
        const detailBtn = document.getElementById("viewToggleDetail");
        if (!bulkBtn || !detailBtn) return;
        bulkBtn.classList.toggle("active", state.viewMode === "bulk");
        detailBtn.classList.toggle("active", state.viewMode === "detail");
      }

      function renderWorkspaceTabs() {
        const browserBtn = document.getElementById("workspaceTabBrowser");
        const bibtexBtn = document.getElementById("workspaceTabBibtex");
        const searchBtn = document.getElementById("workspaceTabSearch");
        if (!browserBtn || !bibtexBtn || !searchBtn) return;
        browserBtn.classList.toggle("active", state.workspaceTab === "browser");
        bibtexBtn.classList.toggle("active", state.workspaceTab === "bibtex");
        searchBtn.classList.toggle("active", state.workspaceTab === "search");
      }

      function renderLayoutMode() {
        const appShell = document.getElementById("appShell");
        const mainTitle = document.getElementById("tableTitle");
        const browserView = document.getElementById("browserView");
        const bulkView = document.getElementById("bulkView");
        const detailView = document.getElementById("detailView");
        const searchView = document.getElementById("searchView");
        const metadataHeaderTools = document.getElementById("metadataHeaderTools");
        const subtitle = document.getElementById("mainPaneSubtitle");
        const browserHeaderTools = document.getElementById("browserHeaderTools");
        const inBrowserTab = state.workspaceTab === "browser";
        const inBibtexTab = state.workspaceTab === "bibtex";
        const inSearchTab = state.workspaceTab === "search";
        const inBulkMode = inBibtexTab && state.viewMode === "bulk";
        if (appShell) {
          appShell.classList.toggle("bulk-mode", inBulkMode);
          appShell.classList.toggle("browser-mode", inBrowserTab);
          appShell.classList.toggle("bibtex-mode", inBibtexTab);
          appShell.classList.toggle("search-mode", inSearchTab);
        }
        if (browserView) {
          browserView.hidden = !inBrowserTab;
        }
        if (bulkView) {
          bulkView.hidden = !inBibtexTab || state.viewMode !== "bulk";
        }
        if (detailView) {
          detailView.hidden = !inBibtexTab || state.viewMode !== "detail";
        }
        if (searchView) {
          searchView.hidden = !inSearchTab;
        }
        if (mainTitle) {
          mainTitle.hidden = inBrowserTab;
        }
        if (metadataHeaderTools) {
          metadataHeaderTools.hidden = !inBibtexTab;
        }
        if (browserHeaderTools) {
          browserHeaderTools.hidden = !inBrowserTab;
        }
        if (subtitle) {
          subtitle.hidden = inBrowserTab;
          if (inSearchTab) {
            subtitle.textContent = "Run hybrid or cosine search in Qdrant and inspect chunk/partition/document payloads.";
          } else {
            subtitle.textContent =
              "Table shows title, year, authors, and journal/book context, plus PDF and text links. If title is empty, filename is used.";
          }
        }
        if (!inBibtexTab || state.viewMode !== "bulk") {
          destroyBulkHot();
          state.bulk.rowFileIds = [];
        }
      }

      function renderBulkStatusAndActions() {
        const status = document.getElementById("bulkStatus");
        const copyBtn = document.getElementById("bulkCopyBtn");
        const saveBtn = document.getElementById("bulkSaveBtn");
        const activeBucket = getActiveBucket();
        const fileCount = bulkFilesForActiveBucket().length;
        const pendingCount = Object.keys(state.bulk.edits).length;
        if (status) {
          const errorText = state.bulk.error ? ` Error: ${state.bulk.error}` : "";
          status.textContent = `${state.bulk.status || "No pending changes."}${errorText}`;
        }
        if (copyBtn) {
          copyBtn.disabled = state.bulk.saving || !activeBucket || activeBucket.loading || fileCount === 0;
        }
        if (saveBtn) {
          saveBtn.disabled = state.bulk.saving || pendingCount === 0;
          saveBtn.textContent = state.bulk.saving ? "Saving..." : "Save Pending Changes";
        }
      }

      function renderBulkView() {
        const title = document.getElementById("tableTitle");
        if (!title) return;

        const activeBucket = getActiveBucket();
        title.textContent = activeBucket ? `Bulk Edit in ${activeBucket.name}` : "Bulk Edit";

        if (state.loadingBuckets && state.buckets.length === 0) {
          setBulkHotMessage("Loading buckets...");
          renderBulkHotGrid([]);
          renderBulkStatusAndActions();
          return;
        }

        if (state.bucketsError) {
          setBulkHotMessage(`Error: ${state.bucketsError}`);
          renderBulkHotGrid([]);
          renderBulkStatusAndActions();
          return;
        }

        if (!activeBucket) {
          setBulkHotMessage("No bucket selected.");
          renderBulkHotGrid([]);
          renderBulkStatusAndActions();
          return;
        }

        if (activeBucket.loading) {
          setBulkHotMessage("Loading files...");
          renderBulkHotGrid([]);
          renderBulkStatusAndActions();
          return;
        }

        if (activeBucket.error) {
          setBulkHotMessage(`Error: ${activeBucket.error}`);
          renderBulkHotGrid([]);
          renderBulkStatusAndActions();
          return;
        }

        const files = bulkFilesForActiveBucket();
        if (files.length === 0) {
          setBulkHotMessage("No files available in this bucket.");
          renderBulkHotGrid([]);
          renderBulkStatusAndActions();
          return;
        }

        setBulkHotMessage("");
        renderBulkHotGrid(files);
        renderBulkStatusAndActions();
      }

      function renderTable() {
        const activeBucket = getActiveBucket();
        const activeFile = getActiveFile();
        const title = document.getElementById("tableTitle");
        const hint = document.getElementById("selectionHint");
        const body = document.getElementById("fileTableBody");
        updateSortIndicators();

        if (state.loadingBuckets && state.buckets.length === 0) {
          title.textContent = "Files";
          hint.textContent = "Loading buckets...";
          body.innerHTML = '<tr><td colspan="5">Loading buckets...</td></tr>';
          return;
        }

        if (state.bucketsError) {
          title.textContent = "Files";
          hint.textContent = "Unable to load data";
          body.innerHTML = `<tr><td colspan="5">Error: ${state.bucketsError}</td></tr>`;
          return;
        }

        if (!activeBucket) {
          title.textContent = "Files";
          hint.textContent = "No bucket selected";
          body.innerHTML = '<tr><td colspan="5">No files available.</td></tr>';
          return;
        }

        title.textContent = `Files in ${activeBucket.name}`;
        hint.textContent = selectionHintText(activeFile);
        body.innerHTML = "";

        if (activeBucket.loading) {
          body.innerHTML = '<tr><td colspan="5">Loading files...</td></tr>';
          return;
        }

        if (activeBucket.error) {
          body.innerHTML = `<tr><td colspan="5">Error: ${activeBucket.error}</td></tr>`;
          return;
        }

        if (activeBucket.files.length === 0) {
          body.innerHTML = '<tr><td colspan="5">No matching files in this bucket.</td></tr>';
          return;
        }

        const sortedFiles = sortFiles(activeBucket.files);
        for (const file of sortedFiles) {
          const row = document.createElement("tr");
          if (file.id === state.activeFileId) {
            row.classList.add("active");
          }
          row.addEventListener("click", () => selectFile(file.id));

          const titleCell = document.createElement("td");
          titleCell.className = "file-name";
          titleCell.textContent = displayTitle(file);
          row.append(titleCell);

          const yearCell = document.createElement("td");
          yearCell.textContent = file.year || "—";
          row.append(yearCell);

          const authorsCell = document.createElement("td");
          const authors = coerceAuthors(file);
          authorsCell.textContent = formatAuthorsApa(authors) || "—";
          row.append(authorsCell);

          const sourceCell = document.createElement("td");
          sourceCell.textContent = displaySource(file) || "—";
          row.append(sourceCell);

          const linkCell = document.createElement("td");
          linkCell.className = "pdf-cell";
          const actions = document.createElement("div");
          actions.className = "file-actions";
          if (file.originalFileUrl) {
            const link = document.createElement("a");
            link.href = file.originalFileUrl;
            link.className = "file-link";
            link.title = "Open PDF";
            link.setAttribute("aria-label", "Open PDF");
            link.innerHTML =
              '<span class="file-action-chip file-action-chip-pdf" aria-hidden="true">PDF</span>';
            link.target = "_blank";
            link.rel = "noopener noreferrer";
            link.addEventListener("click", (event) => event.stopPropagation());
            actions.append(link);
          }
          const textBtn = document.createElement("button");
          textBtn.type = "button";
          textBtn.className = "file-link icon-btn";
          textBtn.title = "View partition markdown";
          textBtn.setAttribute("aria-label", "View partition markdown");
          textBtn.disabled = !file.bucket || !file.objectName;
          textBtn.innerHTML =
            '<span class="file-action-chip file-action-chip-md" aria-hidden="true">MD</span>';
          textBtn.addEventListener("click", (event) => {
            event.stopPropagation();
            openRedisModal(file);
          });
          actions.append(textBtn);

          const deleteBtn = document.createElement("button");
          deleteBtn.type = "button";
          deleteBtn.className = "file-link icon-btn";
          deleteBtn.title = "Delete file and ingested data";
          deleteBtn.setAttribute("aria-label", "Delete file and ingested data");
          deleteBtn.innerHTML =
            '<span class="file-action-chip file-action-chip-del" aria-hidden="true">DEL</span>';
          deleteBtn.addEventListener("click", (event) => {
            event.stopPropagation();
            deleteFileFromBucket(file);
          });
          actions.append(deleteBtn);

          if (actions.childElementCount > 0) {
            linkCell.append(actions);
          } else {
            linkCell.textContent = "—";
          }
          row.append(linkCell);

          body.append(row);
        }
      }

      function renderEditor() {
        const pane = document.getElementById("editorPane");
        const file = getActiveFile();
        if (!file) {
          pane.innerHTML = '<div class="editor-empty">Select a file row to edit BibTeX metadata fields.</div>';
          return;
        }

        pane.innerHTML = "";

        const header = document.createElement("div");
        header.className = "editor-head";

        const fileTag = document.createElement("div");
        fileTag.className = "editor-file";
        fileTag.textContent = file.fileName;

        const headerTitle = document.createElement("div");
        headerTitle.className = "editor-title";
        headerTitle.textContent = file.title || "Untitled";

        const fileInfo = document.createElement("div");
        fileInfo.append(fileTag, headerTitle);

        const headerTop = document.createElement("div");
        headerTop.className = "editor-head-top";
        headerTop.append(fileInfo);

        const clearBtn = document.createElement("button");
        clearBtn.type = "button";
        clearBtn.className = "editor-clear-btn";
        clearBtn.textContent = "Clear Metadata";
        clearBtn.addEventListener("click", () => {
          clearSelectedFileMetadata(file);
        });
        headerTop.append(clearBtn);

        header.append(headerTop);
        pane.append(header);

        const grid = document.createElement("div");
        grid.className = "field-grid";

        const requiredSet = requiredSetForEntryType(file.entryType);
        const recommendedSet = recommendedSetForEntryType(file.entryType);
        const requiredAnyGroups = requiredAnyGroupsForEntryType(file.entryType);

        const recommendedSummary = document.createElement("div");
        recommendedSummary.className = "recommended-summary";
        let summary = `Required and recommended fields for ${file.entryType} are marked below.`;
        if (requiredAnyGroups.length > 0) {
          const groupText = requiredAnyGroups
            .map((group) => group.map((key) => displayFieldName(key)).join(" or "))
            .join("; ");
          summary += ` One-of requirements: ${groupText}.`;
        }
        recommendedSummary.textContent = summary;
        grid.append(recommendedSummary);

        const titleWrap = document.createElement("div");
        titleWrap.className = "field-wrap";
        if (requiredSet.has("title")) {
          titleWrap.classList.add("required");
        } else if (recommendedSet.has("title")) {
          titleWrap.classList.add("recommended");
        }
        const titleLabel = createFieldLabel("Title", {
          required: requiredSet.has("title"),
          recommended: recommendedSet.has("title"),
        });
        const titleInput = document.createElement("input");
        titleInput.className = "editor-input";
        titleInput.setAttribute("data-focus-key", "title");
        titleInput.value = file.title || "";
        titleInput.addEventListener("input", () => {
          file.title = titleInput.value;
          headerTitle.textContent = file.title || "Untitled";
          renderTable();
          scheduleSave(file);
        });
        titleWrap.append(titleLabel, titleInput);
        grid.append(titleWrap);

        const yearWrap = document.createElement("div");
        yearWrap.className = "field-wrap";
        if (requiredSet.has("year")) {
          yearWrap.classList.add("required");
        } else if (recommendedSet.has("year")) {
          yearWrap.classList.add("recommended");
        }
        const yearLabel = createFieldLabel("Year", {
          required: requiredSet.has("year"),
          recommended: recommendedSet.has("year"),
        });
        const yearInput = document.createElement("input");
        yearInput.className = "editor-input";
        yearInput.setAttribute("data-focus-key", "year");
        yearInput.value = file.year || "";
        yearInput.addEventListener("input", () => {
          file.year = yearInput.value;
          renderTable();
          scheduleSave(file);
        });
        yearWrap.append(yearLabel, yearInput);
        grid.append(yearWrap);

        const authorsWrap = document.createElement("div");
        authorsWrap.className = "field-wrap";
        if (requiredSet.has("authors")) {
          authorsWrap.classList.add("required");
        } else if (recommendedSet.has("authors")) {
          authorsWrap.classList.add("recommended");
        }
        const authorsLabel = createFieldLabel("Authors", {
          required: requiredSet.has("authors"),
          recommended: recommendedSet.has("authors"),
        });
        authorsWrap.append(authorsLabel);

        const authorsHint = document.createElement("div");
        authorsHint.className = "field-hint";
        authorsHint.textContent = "Each author uses first and last name. Display is formatted as APA-style names.";
        authorsWrap.append(authorsHint);

        const authorsList = document.createElement("div");
        authorsList.className = "authors-list";
        authorsWrap.append(authorsList);

        const authors = coerceAuthors(file);
        for (const [authorIndex, author] of authors.entries()) {
          const row = document.createElement("div");
          row.className = "author-row";

          const firstNameInput = document.createElement("input");
          firstNameInput.className = "editor-input";
          firstNameInput.setAttribute("data-focus-key", `authors.${authorIndex}.firstName`);
          firstNameInput.placeholder = "First name";
          firstNameInput.value = author.firstName || "";
          firstNameInput.addEventListener("input", () => {
            author.firstName = firstNameInput.value;
            apaPreview.textContent = formatAuthorsApa(authors) || "—";
            if (hasIncompleteAuthorRows(authors)) {
              cancelScheduledSave(file.id);
              return;
            }
            scheduleSave(file);
          });

          const lastNameInput = document.createElement("input");
          lastNameInput.className = "editor-input";
          lastNameInput.setAttribute("data-focus-key", `authors.${authorIndex}.lastName`);
          lastNameInput.placeholder = "Last name";
          lastNameInput.value = author.lastName || "";
          lastNameInput.addEventListener("input", () => {
            author.lastName = lastNameInput.value;
            apaPreview.textContent = formatAuthorsApa(authors) || "—";
            if (hasIncompleteAuthorRows(authors)) {
              cancelScheduledSave(file.id);
              return;
            }
            scheduleSave(file);
          });

          const removeBtn = document.createElement("button");
          removeBtn.type = "button";
          removeBtn.textContent = "Remove";
          removeBtn.addEventListener("click", () => {
            const idx = authors.indexOf(author);
            if (idx >= 0) {
              authors.splice(idx, 1);
              renderEditor();
              renderTable();
              scheduleSave(file);
            }
          });

          row.append(firstNameInput, lastNameInput, removeBtn);
          authorsList.append(row);
        }

        const addAuthorBtn = document.createElement("button");
        addAuthorBtn.type = "button";
        addAuthorBtn.className = "author-add-btn";
        addAuthorBtn.textContent = "+ Add author";
        addAuthorBtn.addEventListener("click", () => {
          authors.push({ firstName: "", lastName: "" });
          renderEditor();
          renderTable();
        });
        authorsWrap.append(addAuthorBtn);

        const apaPreview = document.createElement("div");
        apaPreview.className = "apa-preview";
        apaPreview.textContent = formatAuthorsApa(authors) || "—";
        authorsWrap.append(apaPreview);

        grid.append(authorsWrap);

        for (const field of fieldConfig) {
          const wrap = document.createElement("div");
          wrap.className = "field-wrap";
          if (requiredSet.has(field.key)) {
            wrap.classList.add("required");
          } else if (recommendedSet.has(field.key)) {
            wrap.classList.add("recommended");
          }
          const label = createFieldLabel(field.label, {
            required: requiredSet.has(field.key),
            recommended: recommendedSet.has(field.key),
          });
          wrap.append(label);

          if (field.type === "textarea") {
            const textarea = document.createElement("textarea");
            textarea.className = "editor-textarea";
            textarea.setAttribute("data-focus-key", field.key);
            textarea.value = file[field.key] || "";
            textarea.addEventListener("input", () => {
              file[field.key] = textarea.value;
              scheduleSave(file);
            });
            wrap.append(textarea);
          } else if (field.type === "select") {
            const select = document.createElement("select");
            select.className = "editor-select";
            select.setAttribute("data-focus-key", field.key);
            for (const optionValue of field.options) {
              const option = document.createElement("option");
              option.value = optionValue;
              option.textContent = optionValue;
              if (optionValue === file[field.key]) {
                option.selected = true;
              }
              select.append(option);
            }
            select.addEventListener("change", () => {
              file[field.key] = select.value;
              scheduleSave(file);
              if (field.key === "entryType") {
                renderEditor();
                renderTable();
                return;
              }
            });
            wrap.append(select);
          } else {
            const input = document.createElement("input");
            input.className = "editor-input";
            input.setAttribute("data-focus-key", field.key);
            input.value = file[field.key] || "";
            input.addEventListener("input", () => {
              file[field.key] = input.value;
              if (field.key === "doi" && state.doiLookup.fileId === file.id) {
                state.doiLookup.message = "";
                state.doiLookup.error = "";
              }
              if (field.key === "citationKey") {
                renderTable();
              }
              scheduleSave(file);
            });
            if (field.key === "doi") {
              const row = document.createElement("div");
              row.className = "editor-inline-row";

              const lookupBtn = document.createElement("button");
              lookupBtn.type = "button";
              lookupBtn.className = "editor-action-btn";
              lookupBtn.addEventListener("click", () => {
                lookupByDoiForFile(file);
              });

              const updateLookupButtonState = () => {
                const hasDoi = String(input.value || "").trim().length > 0;
                const busy = state.doiLookup.running && state.doiLookup.fileId === file.id;
                lookupBtn.disabled = !hasDoi || busy;
                lookupBtn.textContent = busy ? "Looking up..." : "Lookup DOI";
              };

              input.addEventListener("input", updateLookupButtonState);
              updateLookupButtonState();
              row.append(input, lookupBtn);
              wrap.append(row);

              if (state.doiLookup.fileId === file.id) {
                if (state.doiLookup.error) {
                  const errorHint = document.createElement("div");
                  errorHint.className = "field-hint error";
                  errorHint.textContent = `DOI lookup failed: ${state.doiLookup.error}`;
                  wrap.append(errorHint);
                } else if (state.doiLookup.message) {
                  const infoHint = document.createElement("div");
                  infoHint.className = "field-hint";
                  infoHint.textContent = state.doiLookup.message;
                  wrap.append(infoHint);
                }
              }
            } else {
              wrap.append(input);
            }
          }

          grid.append(wrap);
        }

        pane.append(grid);
      }

      function captureEditorFocusSnapshot() {
        const pane = document.getElementById("editorPane");
        const active = document.activeElement;
        if (!pane || !active || !pane.contains(active)) return null;

        const focusKey = String(active.getAttribute("data-focus-key") || "").trim();
        if (!focusKey) return null;

        let selectionStart = null;
        let selectionEnd = null;
        if (active instanceof HTMLInputElement || active instanceof HTMLTextAreaElement) {
          if (typeof active.selectionStart === "number" && typeof active.selectionEnd === "number") {
            selectionStart = active.selectionStart;
            selectionEnd = active.selectionEnd;
          }
        }

        return {
          focusKey,
          selectionStart,
          selectionEnd,
        };
      }

      function restoreEditorFocusSnapshot(snapshot) {
        if (!snapshot || !snapshot.focusKey) return;
        const pane = document.getElementById("editorPane");
        if (!pane) return;

        const target = pane.querySelector(`[data-focus-key="${snapshot.focusKey}"]`);
        if (!(target instanceof HTMLElement)) return;
        target.focus({ preventScroll: true });

        if (
          (target instanceof HTMLInputElement || target instanceof HTMLTextAreaElement) &&
          typeof snapshot.selectionStart === "number" &&
          typeof snapshot.selectionEnd === "number"
        ) {
          const length = target.value.length;
          const start = Math.max(0, Math.min(snapshot.selectionStart, length));
          const end = Math.max(start, Math.min(snapshot.selectionEnd, length));
          target.setSelectionRange(start, end);
        }
      }

      function renderAll() {
        const editorFocusSnapshot =
          state.workspaceTab === "bibtex" && state.viewMode === "detail"
            ? captureEditorFocusSnapshot()
            : null;
        renderBuckets();
        renderBucketManagerControls();
        renderWorkspaceTabs();
        renderViewToggle();
        renderLayoutMode();
        const title = document.getElementById("tableTitle");
        if (state.workspaceTab === "browser") {
          browserRenderWorkspace();
          renderUploadControls();
        } else if (state.workspaceTab === "search") {
          if (title) title.textContent = "Semantic Search";
          renderSearchWorkspace();
        } else {
          if (title) {
            title.textContent = state.viewMode === "bulk" ? "Bulk Edit" : "Files";
          }
          renderAutofillControls();
          renderUploadControls();
          if (state.viewMode === "bulk") {
            renderBulkView();
          } else {
            renderTable();
            renderEditor();
          }
        }
        renderModal();
        if (editorFocusSnapshot) {
          restoreEditorFocusSnapshot(editorFocusSnapshot);
        }
      }

      initSortControls();
      initWorkspaceTabs();
      initViewToggleControls();
      initAutofillControls();
      initBucketManagerControls();
      initUploadControls();
      initSearchControls();
      initBrowserControls();
      initBulkControls();
      initModalControls();
      loadBuckets();
    </script>
  </body>
</html>
